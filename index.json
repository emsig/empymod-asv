{"project": "empymod", "project_url": "https://empymod.emsig.xyz", "show_commit_url": "https://github.com/emsig/empymod/commit/", "hash_length": 8, "revision_to_hash": {"0": "51ea4693788a7a60ea1fa62d3d51cdff8cad98c2", "2": "3a112f862032e58018ff7d598ba391910d6cf556", "4": "f7522d972eb4960dfd67d45129284e79561af1f9", "6": "aa255eb62b7c2f3f70d9152e64ac5452143161e0", "8": "cfcddde34d2587aba2541d595c0aea1be452aa6d", "10": "7e72748e8e0e7557fb56480b4b958b6aa4b2f363", "12": "32c3c11417ccb4c780b88822a66879a00ee4c638", "14": "eb1982aa64d9526849d5b6b5b6be9110ac412c84", "16": "89aaa1008a004605a171c516a285b129075c1239", "18": "62133951047bc854302e1791b27eb43690bd22a0", "20": "9a73c304620dd7e23d139c510ad692abc1792b0a", "22": "b729d4af9a6dcc93a79c463a3ac46e727d273d17", "24": "5d98810dfcf2a6d724cec36f89095c8aa2ea378a", "26": "1e678eab59259f6843709afa5e201cf6bbf111c9", "27": "570a1490e63f02b345e0cc7c4c5a646a394c62fe", "28": "fc9fe023d02ae82dc9c5ab4188f6a8dba6f12855", "30": "d4105cd2d167708964d25cffa972d5c98b652544", "32": "2ef3ffc8ce8d5709fed0705bc182fcdc6ff4f071", "34": "c778d76014a42fecf490671f56a00db1e7bb8f49", "36": "ab7d836f5e21fa6679262fce4fefb6ea79b155e8", "38": "acce63dd249adfda932df35db9586a60d44d7224", "40": "899641ddf0f6f595bf612842f4e11d4941c15f17", "42": "5984512348552dbd819e186b3ae907b436ccd673", "44": "2f7fb982808f2527d6ad1ae48664a2c252d54910", "46": "681266c5a66b5e02d47825165c86587945720e0e", "48": "9e0527e74f2a67f6f97be2cc4d8f87196edadbaf", "50": "7e81d97c88bf8d0a5b3cb40a0325e60ec3767213", "52": "dcd9f5395342ad083cf25a2dc25b7ffa753eed3f", "54": "ca493b27e177c60634158a54588604f2ff65350d", "56": "bf716afc8371909d47dadc052c85b31cba078674", "58": "2ce7f6b74382141ecfea07c06e356dcab8e6c4bd", "60": "43f58d22999339459143d3f021964deb5bf2c8c7", "62": "12826f05b829275a75946dcf423d3d791763616d", "64": "4982b9f8e1c724670a11a5b0f162d5634c13bd5e", "66": "898d24951246df2c708670299b68096a71ae0ba6", "68": "9f66591e8ff653ec053af64b138f8c66b16fa319", "70": "9f185c5ca7918c4ad922ae77a590eae8c18c2da7", "71": "9650deee5488b4ad4563eb2f9f2a13e3b0475332", "72": "5c386367d6164a04464d7acf1e549cb92f9488ab", "73": "b36d9ade03d0b1f3549244f1186513c8a2b7ffa2", "74": "51159c576ba7bece6ed8141018acf41cf350f5cd", "75": "d275b4634310d3cc0e824ca26274fc2577c1a6a4", "76": "a1cf888661953dd99e324e06e9fd697c8647f1fa", "77": "5943cab0893db2ee122f685fa9f05af14ece24da", "78": "200e376f104ddc81c214024934ae38fda5bd2a5f", "79": "3da0defc4a4beec6eb2f3905909a5cac78597373", "80": "2a59431e1e6aeec6cc61ea301afc046de8834877", "81": "5f590cefbaf868f09da568b4668b1027c98477f7", "82": "15bcff7b8a99aeabe65c7502ce44e95629dc1dca", "83": "7983e90793b64a357c2d1a37c26543936eebd131", "84": "ee5519f13d507ad23dd7498b90759a33c66c609d", "85": "499c70a229a16238b37fa0f14c939068753ed76c", "86": "765651fd0a6f75a6e6bcf7d0bcba8e821c14cd38", "87": "dab2dae2fd78e6c3e736e654ef8f19fd763385b8", "88": "03ab257edb24081c53d8b83faef6d3ee57c0157c", "89": "6ad74a5968efac0a16af9d4217663375f0faafc8", "90": "f5e3167807f80b7f572b1adcd7225593088d068d", "91": "d3fa70fbc55e0256575ebac4b3cfa3741762d188", "92": "48ef3b6ec6ac0d6e3ca41cc14bf43c4cadd5dfe2", "93": "1178cc56b33b441a52390bb6864870ddfaf3a287", "94": "7f86d5f6ece343336b9a66198abf5c73c92bd6ee", "95": "d69958e42c089c16d8964016c8036c6108efb924", "96": "2217ac44f36e847bca1e5fca4a3f3792fd68e6f8", "97": "79d465376978ed7fb465e5cdeb62701dfb78d9bf", "98": "7121abefed942c478416d86c396ca97d1fe85fc3", "99": "ec0dabd45a0d28ccbcbb6df8edf7d2784080eee3", "100": "34f14deae06f8f27cc767f1150895b78e4681fab", "101": "caa4c7d4eb5d98f7ae5152a56483fd42f265ecbf", "102": "806be5d1c92329ddfdac3053f0cec1d2e626ec09", "103": "e37856eebcbc7c9d2cb448b4ccd5681c5b2a513e", "104": "2adc88ce2d439d8932ea7daa8fa80e7cee1f86a4", "105": "70931bf0ab80e45d8a2607764f93ca9c0fbd1b12", "106": "40f87c76d971e51f1859aad3a478e12647d422b4", "107": "1f518c1ddee16b207b68bce4a703b942320dee59", "108": "1093def9003570d9ff1a70e2d4fbce950e2aa781", "109": "a1568dff23412d69afea65181034ca844e3f4f3d", "110": "0e8bf2225b8172feb61ac81ebc366e142e07d293", "111": "6f285823995506f927f13d69239f03472659af01", "112": "a1dbe8ef5b5fe5b2df6a9c816ca5d2c78a5b7ae0", "113": "cb1dfc996a587692357626bfcd4d30fddb46c3fc", "114": "84a204f01615be0848ac4e34cb63e843b597b76c", "115": "f71114e1184f0c06aee34420f5aeb19ea38051c4", "116": "2ba8fcf4c77c0dd794da4448640c729a4f05eaa8", "117": "a513acabe4056db8add16d808930b174e68f9ad2", "118": "9e24a72cff4a93f5fea96981c213c041812d289c", "119": "50fbab7028040134ce11e1e2e816ab44e3d31dc5", "120": "88ff38c2dc9f9580f7942e58bd6a88c92260c6d2", "121": "070b5d53ab1d6053f4ba74a3b3f8465533fe757d", "122": "1cce1f5d6e6dc16c69a58c2fe78400d3e49f008f", "123": "bd458d60c0b5cc8be2774b7aa698ef1bd6fb2d77", "124": "89202ec5384b1ef5b869d31e480028d183297c94", "125": "d2ff67e8e6d89f94a0ed1e05e696621904ef452a", "126": "9550d2de2c0029a1043d8b2ccc56751c6f07f0ee", "127": "b1c37ea3526eac9130bf09b6ead94808b1fd40c5", "128": "ca6404e9b23b4faaa5d49a3006f5b38e6635f359", "129": "2b64cae79abe17d7888beb3de92ff4c2485bd5cb", "130": "0ce1e3be96b815046101f7b6d0b2124bc802ebbe", "131": "f1719f9d93fc471f2736f814a03fb9d64fcb564f", "132": "4e84e1fd245ea8dd8f792664c89d1183a524153c", "133": "1358b7076ab70af7cb0fde4bfe5d76797e28452d", "134": "42ff8ba522af950034fcf7a099adbbb5729d4f03", "135": "62ec842cfc39fd31840a60252f5067c944b20809", "136": "223968a512b1b32888f35d9a516b1e00f1386285", "137": "18c39e639e0d3abbeeed8f9feb3985de7164726d", "138": "aa2b573f0559312d3e75f642d400b9901d4afcac", "139": "1cedb09ad7c0f98adb6b6e579ff83f69e7e526e1", "140": "f0b915935deb4c261df2c497d3f63e3e2fee696f", "141": "6374fb37a03959a4c4fef3265cb04639d6cf990c", "142": "78a12518c8f1797d7df499db04c8176787c2c992", "143": "b4da2ef81cbe9a21efd2b41c763575b5221b4c70", "144": "f886fa58f45f29253bc185fe83c0120e35c5dcd2", "145": "375f125b185400d3303a9c6b5c225983ed0cee0b", "146": "e423c37b3c63de4e79dfde963b90cfb2427a28c9", "147": "42672fb718014843f2c4d51dadac7263cb463526", "148": "45ef143a1848ff7dc51e1d3aef7847b53cb02eb0", "149": "ea95c9baf48d7b228989d68e3413a184e2ebddf9", "150": "c0f6f5774e42d09b904026f54ec3c6783834a7d0", "151": "9ea49c17260b258ddbbd078ba36cf4a4bb87a7a1", "152": "0661dfa2f167c296e71a92cf0980862b97e1d2bc", "153": "5afde49143629ea857960f0cf4faba3e9b9559b4", "154": "575b57171196d62ed364bb61f8a0343321993492", "155": "a63df6f78072ee636ad111ea222681b57eb2615f", "156": "763670db5be1b63a282015d1a62220588b9131ac", "157": "9bde7c9ee09ada29c237a9114e39ff0db9d617c1", "158": "47ef8f1b32814ade0eff0c0f13a7e1861d1e9967", "159": "44b24097e6eb2af33da16cf87492c3a7a1eb6078", "160": "ed62ad51ac0e9b208684cc3cfc0f47fe1363660f", "161": "4edb2a730308fc5bf3529dc54fc4d12de7def685", "162": "cf7e5241809d238bba54efc1e7a758fe3cbe35ba", "163": "9b39c7db2c27cbe8ec5a68a7630894004d9115c8", "164": "ba51f1e38137f69392a534ff93654639df5d25db", "165": "7571bf7387bd04d6c0aae7225df0dc779dc3c5fb", "166": "e4fc9ffe3eab884e565aa0da0f4c825722f3c040", "167": "ec5112b74a87f84466d0086c87e5d34db68d1650", "169": "1de6a81b7ee97dc7d8a30b006a791d6cd320da1b", "170": "d647ed3d5114cf8bb98bf281063b9e067d34f023", "171": "d36092a86db1fe5ad41dcd681393a84a70561f89", "172": "6104614e6ff63a35831396cbdc3274484bd913fa", "173": "7f0dc47bee1bbba33133a9d6a5b0a97c7734360b", "174": "9a0f38613f9dc7306a8116e5c527f7c5ffb9715b", "175": "90aa868af624ce294aea1c503014720b57a0dc84", "176": "c2f925b95839431ecf1918bc700697d4aa075d8a", "177": "0b7b8b246ea0c3e87be74f2515cdd9089c9e0108", "178": "575451e81d83ed440532645a62af6bd15c151b6c", "179": "e8f49783c59a230ebe28a98310125152609ffa91", "180": "d9105a954ae863dea72ee2e8c706d2c2ec70fed7", "181": "37ab4e9d7942509f603f0210c1e965c2f2d79a77", "182": "463917c770dc73186d543f6fa56fc0cc428d95e3", "183": "b43dbe5bbc058a7ad2bfeaa2fcbc88ff803c20cc", "184": "8709dfa508b85ea002181757a10267c27d4d703d", "185": "53994cdb7303fe4311005ae6407eb98f08eb432f", "186": "f3f3cc526a7b1db4ea016498696a701577c7e61d", "187": "75a3e42b3d951c8fffeb2de9cfc92b250a5544c4", "188": "b8955417b68d9a41f79f9e7ec11154496ec0d192", "189": "f0499e10c06812a4666c5b8a3f5988f7635320a8", "190": "6e9d5c1d9be865e09f29424ecc52980216c18f5d", "191": "03a1f3d5ce3973ffe9bc2dd514014cb61f130f6c", "192": "84982c53b6bf90792c9c3916379b57203b6a15da", "193": "f41f73238fc0b348ee72824833206b56347cbd49", "194": "76af6fe247c51fc8a9b37579f471cce253b17373", "195": "5dd0e5bd42b3fc2e81e1d7e376c9476420f83df6", "196": "42a92b58ac0abaeea89d17af3f635bd2e43d3a9c", "197": "ca683830d5bbb1e897f8a7c86600867f3deb891f", "198": "9ef62c0b82bea9cb90972fa1cb2b9afe5abc6c8a", "199": "c170fb7981410077796b0a63cc11053e81c7e7ac", "200": "27d24e08a73008154321aa5fca687686b37e282b", "201": "42bf6495db19ac056014964285537b3d9eb711d2", "202": "e95bfd3283f8a7a6b25f065c3838435dfc97247f", "203": "3b637d28e8631cc38d9e544f54dbc7d512485c38", "204": "d9b563bc5eead7f3369ee96ff8a8394e8068628a", "205": "f1cfe201278262e7447d36df8e0f5b3a659fc3e3", "206": "86ca45b2cd6ae9b8d4a3c99d1b1c421afaf88ed3", "207": "8d69ba9d95a6714bcebebb9bd8af68def5e33044", "208": "7d8a8d124de947b66628eace2013dce16f979ed6", "209": "05b9fd4c471038428e9e845371baf3dc23c0837c", "210": "0c72237418affdebfaaa3f9b30e9a95d4bf76580", "211": "89a8b2aa7905ea676ccb548558874fc11da9e194", "212": "fbc8d46ca19cc378a18271fa3a6cfa81f1ab4ccb", "213": "6173b249088832209172e9d127374b01e87d4210", "214": "599a74007bfe2cc2bf844010cd7ecdd7093b270a", "215": "b234a811cab83ca7d9d2250457a364eed80c39c1", "216": "4d6f832e043926c8442cf9c4e2cb0855988b8552", "217": "7ff4e4a61004fe52517ae92b189da1a418eb6bcf", "218": "efd49438a9f4772355c331b18cb7ff7e684b77f3", "219": "bd3c58bd2419d358d71f699808dc6ce780e2dc20", "220": "b8a9d9d68326fed5f261eb1453f7fab3dbfd54ff", "221": "43f21d3eca469b2aa8625ee3c1763c20ef8c0224", "222": "d15a92fb601ca72c378c10e39ad0dceeada250ea", "223": "283f510f121bd664527712e4e94628d6e25f6f23", "224": "fb0b3e337a88f919d3566630869a1ead9f3ff7cb", "225": "fd5859655981e9f6a9bd3fc63ba3cb70a8160138", "226": "1e1dc550ef6f99f49269c7f06a3bf101d6577117", "227": "4b17dcc6278c5ba6ceb260adb8a9f4b92b002f4f", "228": "89f7d54c7f146113a922703ec668cbfda58e67d4", "229": "ea9098d7db2242af66526c9afcaafddd001ca6af", "230": "4299ad2416369fb8493dab681ac20782fac6ffde", "231": "3bd6903ccff1ec28370963c5742bda73deab3543", "232": "3dfd66492bcfeb6fe1e9f8b75bc75a1a315370bf", "233": "1b0961f07da89ff16f9350a0c9be1d1d955153db", "234": "4f459fb2c0471e64df4679aae0c041de0f0fe1c5", "235": "7615efc250d2518cb0dc43979ea2fe3a12e070b3", "236": "c719ba85008cf5358a76b4ea638b0811ed4a7efe", "237": "696ae2b08cc6a93a6a257fcad742f209fa8bc330", "238": "dcf86eb8b8e8fb630972e542ca2f005efc7ba7fc", "239": "bc67489a4bcda2821c9d3868fdc58bc66e6aeb2f", "240": "39382f669c77bca000f268efb138e67dfb5b5dad", "241": "bb617eea623d79ee5eefd9bd3ffaff547811f1db", "242": "a9be8d848dca4271592b0fb96897eaf4406732bb", "243": "46b3dee83e9383e4c95290b68dce9898c07d4856", "244": "c242aca34511da2c2756254d09deeb8629a72166", "245": "eb64147340ab7932e12b479a3f7c8bbf3b3158d3", "246": "eba555b163039d3f7038c21fb80285f66a4d046c", "247": "69c322f3d425a00c5a3d086a15a5fcd0843c5dcd", "248": "7f989a9b23fe5e3a758eceb56b106b9024027e25", "249": "ebe210973be216379645de32165130f653149c50", "250": "9458e7de4cf40394105d642b198f935c561628eb", "251": "23d70b8ceb477bb8b06bb8c290d697e2fac251f8", "252": "adedcfd48c09ed13a6f2be074e4d7eb8c2683554", "253": "ebda561c13a315115db70dec54ec37cf1acf794a", "254": "b9cef84d24db268b21996a67de5d71a5cebf214f", "255": "7114b1e5eda0799716eed638a923907cbbd81571", "256": "b7d68249b09f3bc7eebee93bc0f76180cc09e090", "257": "b0cfba880888f0f2faa5d00684e29d8fc014c8f3", "258": "7ffa82167e75c9acd5b9e3de28f8414f1be751ab", "259": "7a3e1369387d360820014250ac6564cb7689f2f1", "260": "6d9f210032e49beac6b69913d40560f7e2a84fcd", "261": "61b4877917fabb0d9c1006483aef6125a26082b9", "262": "2143896a172e548f3e0b070b089cd7fce380475d", "263": "7429d0ad5bed29b840bb1e500414ba4c77973e56", "264": "7efcc9c83f566fcee12076dfc26827d33f3689d7", "265": "fa2b114c646385658f2f0c92e01d0451f3d75466", "266": "2f7afb98c9f5341ca2e2351c89545d524f2ccbf1", "267": "3aecdd7de45578107567308aedbc1f8922238f1e", "268": "e05968f68f726cfa5ca6575615910951c07d9eb7", "269": "aa59e6afeee8da2effea59ffa40fd88cbff78ac8", "270": "e4049c05e7e143695cfc5f143ac108416eb5c3bf", "271": "17a9751bc593d0cb47689dd5eae1473b7e963a88", "272": "a8eec8a9c3e64806d097f7ae56ec49f5f7911f1c", "273": "745d5ba10b63dfb23196de126b5681cd97070b5f", "274": "0cfeeb1cb91ef7568cdc74605fac826922a0b6ca", "275": "4c8f68add9376c30f0228a15a045d7bdfa5e85f5", "276": "157065571c89696c60d7f87d4cadee2cb23981fd", "277": "5fa26c1c7f8f18cd472d97ffe4d30de74d2ea940", "278": "8ead40f2621cc9206215e3258069224077c1725c", "279": "3283152776831f2fb63cf64cc73286a849bc818c", "280": "97e006727bc4d3e5b276f0f50ff6022e396f3694", "281": "88dd0927f6e3ce44690a8f5768d6817a39e8fa43", "282": "ef6531620955c5636f4649f2856063760c6ae7c6", "283": "317707d381734870d77b983499b8cb6701de1826", "284": "546235981e943ebdb398c17209a77ecb0d645cda", "285": "3e1dc3007585d966d940a9f5ddba3144510dffbf", "286": "85e83fca44830e9a3e935e1d7fc77ee9372a041f", "287": "c57b730ecd38908a5e4db6de514442158945e0ee", "288": "8b7439779411156a6b862fa4ac6eafc557254cc0", "289": "578d5f5b0ac24115f69b9d986c330bba630df070", "290": "28b9b1b3a825f9ff887a1c657d0d10ff6a04101d", "291": "c13675cd8ba6ac5a270f71986af0265bbce91895", "292": "5671d70a15ff72053c283718e65baf2881d5ca55", "293": "5f8c2859f0dd6b8e445c595fdc1e43badd0ac9de", "294": "fc1e4ac134e2a1393bf56250a5781a9acc8660ba", "295": "699e2a3f129f22be44a6740e3aef0d47eba96273", "296": "970f965638355e91ed57b5e63d831d5e97a3b6a8", "297": "065f71fd202af52a86c823dd5493c0d64dabccda", "298": "2f102d23fd5d2a7e323877d0e0d2260967cccfdf", "299": "b64fe0506820e4186ace73fcb84877d7b03d7226", "300": "77ee51d9378057ad90cb655b9ecd4b7cc244e4c8", "301": "30c5456dd136fdaaf2d82dff9bd8aac51fc399e0", "302": "65017154da09c3eb88214cc46abfeff50e3dfc69", "303": "edc60a1623830f50d67656f6d32fc03b1cb50304", "304": "f3142f668b590eb27e838b7014871ee4388c78ee", "305": "a51f139e08efa119eab940724035cc7570048a11", "306": "f3fcf41207d1d82974745fef472b5610c3cbaf40", "307": "cf3ee7f1ecf77a8886def1185d4bc030815fd465", "308": "ca7911d6dbff5a283f4687e3b0155579eac948eb", "309": "001b9dd712cd240316657c9143706858e23b3308", "310": "5e695a662ac4040bddba2c7d49f5b4384a4c17dc", "311": "7f9667140bc6d9824c956397a8730f9e58df6afd", "312": "0259b9b3c625ca6b237623c11903d24dd4bf1032", "313": "f43106900c36af716f500d3f07bb5e15a2d39a0c", "314": "7bb01ee6914d295c7541acdd0e27d53c311e991d", "315": "0e001e6840eb62c7ba76ae01468011b81d99d776", "316": "6f6170cc613196aabd3c11598a7552eecb9e13be", "317": "ddf19e0b6252dcc8b82624c2584daf52b7e0d4e6", "318": "979e897be44852ef5381448f216b1bb1817178bc", "319": "f94a9dc370b9c1a2daafb43916a73edf54475616", "320": "9723f4dc765438550c0fce1bb6279ec7b5d32cdf", "321": "3f5f0fc6f14f8a692978b4449325162a2257cbae", "322": "15091823dcd94fe9c3f77af0e93d7368562344a0", "323": "64eec6aca4233fd0b452b69b2dc15747d5454d52", "324": "b9371d93bb107b7b6304cf2cb1b378d4a75e7175", "325": "e2ac02e8d6a7c981a6819a9314de9856e74d7deb", "326": "9bed72b02bd79020227557dae39d7da5f3ce0465", "327": "8081a337253cd8bb4b1ffbbfba20ea9974f8489b", "328": "b82c2bbf3e4e531836576e052e339528bc47c774", "329": "32c2878377b6dc50cb66c34f266a3f55c4db7443", "330": "4cbcb6f040229d68e56e777c652fc7175fc0d9c2", "331": "07a0db4d7bbf41dda77d53c971ccd92b0e50b0ad", "332": "e19f4062da46be7cf98f30e36eee1197bb7230a7", "333": "9148e967787aa804305bd547965a8f1c0ba51127", "334": "8141ac85e316a3b372619f157f796cbbafc411e5", "335": "c157a5cc6eeb824ed78c2718574b8b2eeae10f15", "336": "b062d61d3fec8c71c330342b939bc51f94b586b8", "337": "7b72475e29f5da429c54d1cf6fb091bb25b71a31", "338": "a6920e854a6bbfed075de9e8611212f231b3afc9", "339": "0934cecf91ebe0c3bfcdee7bd3c6f6f76e84aebb", "340": "14d44ac85455d82ec26850e71525dbb2cab2ee66", "341": "0db1c3437df02f566180ab2b8a463331c553dba7", "342": "4739c940056c6fea4bbc1f3314faab9bc71c0826", "343": "9773a9c656b60912a637f155d35219631373b0c9", "344": "c8fd726fdbae0788da2cdbb88e77c8b81edd37dc", "347": "397a91721460d206e939b049f569bddae15ddd45", "349": "8e85f3beb412f0e8e4944959615c6b6d514dab44", "350": "a15af07ec6273d49d42005442d6aa21d23c3a7ef", "351": "99cf0df40d258f8e925f8d29e127dec1dba3fcf4", "352": "de6c0eda555ce59857b1fd48e54b7946e25917a5", "353": "8df93987db4e5f05e36310301fb9ce6fb4ac297a", "354": "e0bef7122f319e22d8a935fbf6fb8b4dad8c63c1", "355": "cc3b35705e5df72a10e9c62a16184cc5672307d1", "356": "26ef1a04f608158f5ef14fe5a2d54939374b4e20", "357": "f59e16e7429ce6d023aef17c58f759b1d196cd66", "358": "23bb16bce6358a0781992a31a5ca8b7305bc7482", "359": "ac6de61df8cd5b1036d44ef257476f8054662f4b", "360": "86073cdeb0a1a948b98e56fd3c0397c86fd6f36a", "361": "b172cd6c15cc851e8195cb13d2cf205446a819a5", "362": "9f2924205de09713621b4a86ec2767fe8ba447ea", "363": "438056c44c9f4f534af2ebb75402c9ea69b17670", "364": "5a65bcbfef060698b426717c219877861300f5f4", "365": "4fa7e9b58bfca896077f434cd5e2ab71dc48823e", "366": "bf6095382e09a8264b6d43a5b174737c30d45ed2", "367": "9e9cc1141c85b821849376bf065d4687fd0e34e6", "368": "2d3171afe8494f5c532c0526578db8620533b820", "369": "09cd0f3c60d50b9afaf2e0707e0eb620dd6cfcaa", "370": "7caa319e14e04658bbcf5237a1c5d9453870f381", "371": "7c386b6dbc197cb837c61a86eb041385f711e1ec", "372": "8aa4e56d9a0fab1a9758f619a73e496408fc3fc6", "373": "5eba63a76f989f65457092a92459535bcc9c0d6e", "374": "b271f1ffa8c41ef3af7014b8bbe7b3ae610c7bd8", "375": "3b4370da45b14a3b49dcd16827451342cb765e95", "376": "3a48704dcc79673685c14fe1ef8003f1235f3998", "377": "28daea451a238dc2affc80fa16e0b963446cbc15", "378": "ff54aa95062490cf43d5aa8cd55a28db410669c6", "379": "e36583d237060c6f05341847863afbe2c71544a1", "380": "85d5b4d6c497f0a4cab4328b887a27e8994f7b29", "381": "77cf644928d986b8de3cb2fcff424edd21dfc634", "382": "5c3812126f6ae79a0cadd85ddad431ee4aa91826", "383": "99ba879b9dac934aaf10c3dee5b4bb771955876d", "384": "9b4cb61b9282e06100e502a03b6aa63986c7d266", "385": "cce23d760763e143e46482197ad7c68945c35b99", "386": "4be77539063f0530a3ce9885879ff8fd8e40ed36", "387": "58324fb6f4e881126af68b8f7389f554897979d5", "388": "98bc43882fe9b8c1573b4622a878d76b3d2f6c70", "389": "53aa8a4fc3c0e6bdd7cc19c4c3d3dacbea7c3b45", "390": "7a0d994ede56c52afab1165788b1a3a7dba25b93", "391": "2f63ebbfe51b633940669752eb22a1a79b6b62c5", "392": "c8ce2c706e375580c92bb15bae8d4ccab67c4755", "393": "fb67b790fe05a0bf57a168a9411365cc6a10f0c8", "394": "24c10aeceed73a4ddde45b4e7c606ccbfaaec858", "395": "8fb50c65f38e402aee88c9d1a028729286f37c01", "396": "e07f93dfaa0932a66cdf4315faad5a441067d2db", "397": "13fd55fb796e6e2bce1845a33bcfcea324be639c", "398": "113abe18a35a4d8c4211865cdf03474231a129ea", "399": "6c943bb40fad383eb3e2cb67d2c465af1500831a", "400": "5530c5d44c1260751cb29766c9daf8e9a6843b48", "401": "9743e42130804e1420674affa1766236d2392b9f", "402": "b905a4bfced417cad04ab7b2d63c04e141f7d95f", "403": "22fa7a1203b3943d265aae52f7055096d80867db", "404": "828f483341b7c1f386b0026d908a5b70edce4682", "405": "8e4f016c9ac25235d6651b1b12e62c464af1b998", "406": "94ab3850e9e5caab28827de9169d0f5e9f4b8967", "407": "4ecf1dd0c7618b4de3ec83d06ff213bb37e0ee14", "408": "e1eb89092cce4459f2bbdd977d6fa5fdd96b2e5c", "409": "4d93e72a4e7ea8590ec7c1f46bb44b4e0c73939a", "410": "2599cc9668fdcdc98c3b88e2b4c640ad6d8c36f8", "411": "0c3f16797ef99d1e757a71952e0fc43be051ab30", "412": "d111b7d5bb04be774d0d8487970e874ad9b15e45", "413": "6f93b62e905cffb3a339e5eb27646c363d49bee5", "414": "1b3ed0d57fd09f2ffffd68c6924cbfa59a1e6cf3", "415": "15890094242169923b5350f3259c96c6dd7ca017", "416": "8e1e978c8858568a3281c42e9fe87f61af3eb095", "417": "dad8eee83d2f9fbda5b73899fe8d4a8834352095", "418": "5e8f9f06fa31a0b42baed42a0b92718ceb3ecf67", "419": "676f6a03c3bef6e25247f0c4b2638b78fb29017d", "420": "b5d329f0e1d6916dfaf41b921ccbab933f185505", "421": "95a158490a0157ba7ea6fd2f8d4332e69a81554f", "422": "32277a8d585386d1822f8a308c1ac480f301eff8", "423": "928f2b0dac6d0d756e03bc2eff0874f9d87ab2ad", "424": "07ce676be4bcae37d7ea2cfcfd4fc6c9b6a69341", "425": "201f4e492298341421f72813e89f54bf06ca0afb", "426": "130315cfcf1ebf7bbabeff03aefa6979294f9e19", "427": "b804477ac1a590206b68ca5cbb18b8e902e17699", "428": "1333f79f4be923ee56a8c201981408b206c4cae2", "429": "0c497236f7e12631f1fd52ecf34897242165aa0e", "430": "4847114e1689365b6d0c138fcb7dbfafd4da646c", "431": "4e8eaaaab171e4bbdb6c58289c93bf46cd9eed53", "432": "867610adc9b12ea4a8941435da715dc1f9e12be4", "433": "b7fcb1eaaac3b1115dade591514f427802310740", "434": "851c5746582fe4e76326dcb991eed0995e8d7bcf", "435": "7e7347cfc282cdb525df688ae9592def360c60b5", "436": "b179dd5e16670102135d12b6e2dfaec8211a5663", "437": "59dafe46fd9e9d70f629c0197a9f24f9848f580d", "438": "07dc0b083bde1f8613d46312d61ee16481d91b37", "439": "ad11bd144be71d9b8ed21cc2ecbc2e7f4850d71c", "440": "c28cd7d692a1455f116c316a26abc0e2b6e7b85a", "441": "af3714df73527d451f45d74af44190df8c93a8e3", "442": "fc74cf74f1d6c56a5e8cfafe86e32bb4237eef7c", "443": "472f41ec62248226a142d472d53121ef60162dc2", "444": "4c23289837ce600ab07642f21d447800c725b045", "445": "85ffc6c890b3b3132a71c790a59db376279350fe", "446": "16a64c5e9a042365521df8b9b33a63cb40d5339b", "447": "4a54e3ad0dbf46b4413805232a119f35a8ef03ae", "448": "0fe23637a8ec925d6addd0d0587fa549b4efef37", "449": "297d8d2196062da5081efbd53c155bccb79da295", "450": "bd58cfe8af19393d7a9be19f81cdced1ef52b216", "451": "bb6447a7979ff1bda107185fbcc4c2eac72087e6", "452": "b6f68727ee0f7d19c9b64d543cf449f1b1816d36", "453": "4a3a1a3355345d017724e901ab1833101bccbfb8", "465": "aaa61c82a1e2b5a23a94049dc2e8afc51ef56598", "466": "23828987273f84d2b56022d3f2f75b370310192a", "467": "f325321b55c6812190ab1bf8e8d00056a18741dc", "468": "3d54082f5c791f27526ab7517d7dda5ca2f34a56", "469": "15ccb3334b89439232b23a752ce4a7521db577db", "470": "3a6dbf45bd2dd4effe83a78d21ad80c62f17502e", "471": "f35b3bff58b9015b14b2916e68db100b3fe57a38", "476": "834593a4bbe47a6bdb289e0e222eb3891582c00f", "477": "adf85ea604636b57153ba6309a81b1033888bc91", "478": "7f5e84b20d6846fbed87277a2f8533dcc0b70e88", "479": "a1e15cc5cb65b558971c9a8a6d0f884e18c0b120", "480": "96c0d16c124ee490f39eba6652f94b3909281a1b", "481": "a314092476843b6423475e485e9c8557dcc823e9", "482": "1e471b68ed2e3e3921b93c71041c770a840aa0d0", "483": "b85b8b40f0e97eb837f0ef025d4a99161f2e23d1", "484": "cbdac0c54446f1f9beff8d1de3bbc2f3f6c2011d", "485": "884d72d295e88dd5e43369afe3fddef9b3f621da", "486": "dc1152f83ed7e4f6422d50cdbf3b583dedffeaa8", "487": "84fe502904061b012c728f594781f694738fca66", "488": "5eeaabbd81bec72019c7586d979dd0e2fa2151b1", "489": "57eb34ccc1c0aa5e722c34c073524814f0b98f51", "490": "9da6f961074d5603a45c69e97c9ff7e5cae80579", "491": "e095fe6d4d2ab86be2e6ef4686801d6dfd7bcb2f", "492": "819dc594d9a8c41e9e1720cd55f66c7bf1404aea", "493": "0e04d8af38427c7f414d472da08d22578c5f3bd2", "494": "155f808db441ae2975f77546b12709b254043c2f", "498": "08c987df6eb2233bbbddefbdf4aa20588408f8eb", "500": "c1355afcbb8b6cb21569d4bf389a3169020cacad", "501": "27007b39f67cf31653b73aa4962ff40ded4f5154", "502": "ae024202d87c2a438721db17abbf79f9fc6868b1", "503": "3658ac646af67d6901c00527388557e82940e1f0", "506": "4ab661ecf47453dfd3245654cece0786c885a8b4", "513": "c0e1d574c21f833a906320667f35820d40bbe80c", "514": "1c552250050fb7a95adf02b5a8f22b610fd76aab", "515": "86ed6e3f9ffeb7192313261b55291eda63f92f6a", "516": "6c3a92cc6ce366eed7021723e1b9f9071389fe82", "517": "ae02a7bf63ff8e11ba666e7f76d0d88ffb9566d5", "518": "4a78ca4191ed4b4d42d019ce715a9a3889dba1bc", "519": "c4714196316cb15d9408af34b9d0b2beef1cf63d", "524": "820b88a877bc4aed5b15ebd96899e03b33dd3d33", "525": "62a2533ef02bd840d8ebaf520ee9226bb241cee7", "528": "ddfcc091900df6e2a06b3f0be23c2d34216b5a1d", "529": "b6d1343db160d26456a5828552916cbc6143422c", "530": "97744f196638700f6859134876bf391a77b4c42f", "531": "fd9808c450f8be6defeac0a6a22741379fc92392", "533": "eec05c7f90228e299248d737d14cceb771d28ee2", "539": "d8d6fc7ae8aa93d241061bed9d0a22e94fd0eb63", "540": "974cf1200f59bd3a043eba1144126cb8f4e195f5", "541": "798824649f236417033a3f9011faa9759b31f8f6", "545": "83a8c6f2df85728c0c557c3b412c723ca52ca40e", "546": "7f65e3a15855359334d2311a9b278a05834340c4", "549": "9a6e510504f90d6ebe4926b10191ea5418834842", "550": "78bbaf820a9d50ea7b3c25733bc3a20cf6e2c03a", "561": "137ce9804766db76567584a9c1863964a75ea0dd", "562": "b87570c6eec336a6f94173cc73a6f7dcc9397d9b", "563": "6a51330739fd8b80fc6c4459ceb8f67916c583d5", "570": "30c5f23166b1cbe240b8c37a978f50e7e9272171", "571": "ab2bafd2fd51965c700570dddeba7798bba0d06d", "572": "da02da291fbc70ed3a1bad1e5e890f24abbdf32c", "573": "3b9359edcc8a74c5dadbfd1d286f8e76c2ad79c3", "574": "1f37a2ae66a84907af331fa0242353bdfbf5afe0", "586": "94e2cdd399463c119d02f9abe08d4ca1a94d7e69", "589": "3ea682b2f1c40f7d787efea426f0b938aa14053d", "592": "e878f4f57a6cb5a1d77a140b2ea1085d9c1c5341", "593": "8c7ce6408c5289a3ac773c70a6669aab77a84e06", "594": "32c40e7cf96f02c5dff798752df2fbd2a0b8546b", "595": "2bd7fbaa3b4a032c125ed5fdd9939a58b0751663", "599": "55a38cc95c14558b15356dfcfe1ca2b865a8a02b", "600": "3bfd5642566589abcabde3a7460b2202abc1e81e", "606": "d1cb25ec567b22493f7d8f2cb0fb0e7087d0b9d0", "607": "20b809bd9ebc0d8238bee714f4b1246dc03a0424", "609": "83272a9f144516a525cd6f8824c14966451bed8f", "613": "a7a06d2b87cef062055dfff86c5c6697b59363ec", "614": "6b404ec324a517c49aba2ed759a6a90475fa38f6", "622": "45a972b96bb62e37b7da00466be0b840476b0f48", "623": "367462d7bf355e6c03d0eb01a146f18338177ec1", "624": "90355357e91123ef31db40c099906648bc14ceff", "626": "6080a6f328aee9e0826105ea71348dfc3a476260", "627": "7901a9e02c410892bee7c233ca1d08c9ddb7cecf", "630": "99eb872ccf6eeeca4618f9aeb64b874e07fb1aeb", "631": "3cfab6a8deb1a07bc897dcf9a3962d51f104de36", "632": "c01aa9160b05aed6ac4e57d4dd20dff33d6b2e50", "638": "deeb075a8f75dccf7d04f9df861572b5edd848af", "640": "87ed2513cb25669052ed7bc8152dc04ec05b0bbd", "650": "70aaeb326476234e4b084b146c279b5e76d08867", "651": "8cbb54ff9ace150e412f42970467d3f35916e3aa", "653": "a9f52960ec254b0efd1c078e135633ac6df61abc", "654": "d695ca134b4d6b7ea0a287f28dfc27e58ef4f035", "668": "ed96a5731f7d43b27db777315e007c8e3a5d8be3", "670": "d18c208d1d1f768b4215b711a0f25fc45e7549c1", "719": "407b07319f438afcad217b6e0897cc0750e5f39b", "733": "7154fccaccad823ab14425adb5dc8e6d741c68d0", "740": "eeba70bfa98afd285d2311c0743c00a6359c20cc", "742": "708472dc1cc8c4843ffc6109fcb3592e507389ca", "749": "d531f91de6497b53341676d636de7727aaab800c", "754": "4c8bf21e06b804914f4321c65bbdf79b4df6ea1a", "760": "99b7ff43195f553154f752ab816d969adf3f64d3", "762": "350d91df5f19516fce078ee42afa19f4d3659d85", "763": "edb4cfb633d698191e28350841e9d604fcc61306", "766": "90e487aaaf4cb1d337bf02ad2aebdaf56de37d21", "767": "5c5fa1b45f18b0dc366e96bae8f2424711f7f2ba", "771": "3ff08e1d086f2c195553754673b57531fbaeaaca", "774": "acf27bcd2226ae2f0b49304efa6aa20fa97faa9e", "779": "82c47306bfacde9a8d0c2ab26687a67b92280287", "801": "eb0dcebdf4edf37cd5726ba82898385f52073169", "802": "46667e8e44d55e5c5319a102d55ca28d2e915259", "807": "8eeea4ffd27796a671554e1ef1238e9b14ec28df", "808": "f0fdea061c2a9b4eb1c46e3463ff904657c2e850", "810": "49860c781a29420d355ab3548ab22b93a02c28c7", "811": "a776c8375a710434c2e08fb0d2760eb1cf34c6c4", "813": "4ac8accc755001a88ee9dda9ec8b04808e9741e3", "820": "bd256979d8b76e110b1bda4007c85f9330eab7ed", "822": "64a7a82a88d80071819afaf4e81e280d71d2c6b3", "824": "d5ea41e7cc75944dc53b14b66c248f366ae42e9c", "832": "ace1b4faa4fd0edb4d16e93ba8edf37401271a7e", "838": "289d8e29cd4109a55974deb1e3dbdb61f46dc152", "849": "8676702c52d55c79e8b91008daf5d8ce7241478e", "857": "5cd4e46a7112c01b2a828d4747084884190db760", "859": "c646f27763e54271f187e87c4082de654d37c7e3", "863": "dfbd730a27517e924d5264085cfc38a6b065ef90", "864": "abc445b14b5666304f22f55ca3bb85ca1cc35d62", "868": "229f8de388edcfb10cea9f582046f2d660332ff3", "871": "f3174725390524b8428887712371784b425a2417", "877": "0467d97a8ce5e09476933bdbb84b40100e4f3168"}, "revision_to_date": {"0": 1480176354000, "2": 1480177620000, "4": 1480180677000, "6": 1480180917000, "8": 1480189972000, "10": 1480190222000, "12": 1480358213000, "14": 1480459310000, "16": 1480459414000, "18": 1480459508000, "20": 1480459568000, "22": 1480459631000, "24": 1480459893000, "26": 1480471545000, "27": 1480471545000, "28": 1480546458000, "30": 1480798247000, "32": 1480973375000, "34": 1480973458000, "36": 1480973740000, "38": 1481253121000, "40": 1481568529000, "42": 1481655652000, "44": 1481659424000, "46": 1481670432000, "48": 1481752960000, "50": 1481754571000, "52": 1481755379000, "54": 1481776315000, "56": 1481843307000, "58": 1481899080000, "60": 1481900737000, "62": 1482176372000, "64": 1482275521000, "66": 1482344962000, "68": 1482362662000, "70": 1482445226000, "71": 1482445226000, "72": 1482507762000, "73": 1483544522000, "74": 1484002987000, "75": 1484089307000, "76": 1484172316000, "77": 1484178835000, "78": 1484262416000, "79": 1484322271000, "80": 1484342254000, "81": 1484369657000, "82": 1484405118000, "83": 1484405155000, "84": 1484413868000, "85": 1484417494000, "86": 1484428042000, "87": 1484429282000, "88": 1484579579000, "89": 1484584395000, "90": 1484586741000, "91": 1484589082000, "92": 1484670334000, "93": 1484675598000, "94": 1484676115000, "95": 1484676825000, "96": 1484677125000, "97": 1484677667000, "98": 1484709977000, "99": 1484710248000, "100": 1484710595000, "101": 1484711208000, "102": 1484711641000, "103": 1484711811000, "104": 1484711994000, "105": 1484712769000, "106": 1484714704000, "107": 1484714835000, "108": 1484766194000, "109": 1484797298000, "110": 1484884656000, "111": 1484885418000, "112": 1484926542000, "113": 1484931164000, "114": 1485230524000, "115": 1485316572000, "116": 1485316646000, "117": 1485318297000, "118": 1485364274000, "119": 1485364412000, "120": 1485364676000, "121": 1485401757000, "122": 1485402360000, "123": 1485443154000, "124": 1485443644000, "125": 1485444049000, "126": 1485444852000, "127": 1485445210000, "128": 1485445470000, "129": 1485492588000, "130": 1485551200000, "131": 1485561571000, "132": 1485573054000, "133": 1485578074000, "134": 1485635089000, "135": 1485641888000, "136": 1485694318000, "137": 1485804562000, "138": 1485835172000, "139": 1485882234000, "140": 1485885722000, "141": 1485885749000, "142": 1485900562000, "143": 1485976738000, "144": 1486007981000, "145": 1486091051000, "146": 1486093145000, "147": 1486400152000, "148": 1486439825000, "149": 1486475860000, "150": 1486476841000, "151": 1486565430000, "152": 1486609985000, "153": 1486958484000, "154": 1487222516000, "155": 1487442627000, "156": 1487443263000, "157": 1487454140000, "158": 1487456288000, "159": 1487806579000, "160": 1488051258000, "161": 1488146478000, "162": 1488213422000, "163": 1488247874000, "164": 1488387127000, "165": 1489246169000, "166": 1489246803000, "167": 1489248017000, "169": 1489249068000, "170": 1489249699000, "171": 1489252095000, "172": 1489271443000, "173": 1489283390000, "174": 1489341763000, "175": 1489343819000, "176": 1489344461000, "177": 1489517553000, "178": 1489534921000, "179": 1489618845000, "180": 1489759092000, "181": 1489808652000, "182": 1490029078000, "183": 1490042674000, "184": 1490042853000, "185": 1490287211000, "186": 1490287253000, "187": 1490295557000, "188": 1490308972000, "189": 1490390410000, "190": 1490397227000, "191": 1490460984000, "192": 1490461012000, "193": 1490548295000, "194": 1490655017000, "195": 1490667860000, "196": 1490702930000, "197": 1490710223000, "198": 1490723078000, "199": 1490724710000, "200": 1490886712000, "201": 1490890605000, "202": 1490891352000, "203": 1490893728000, "204": 1492449433000, "205": 1493423535000, "206": 1494694739000, "207": 1494883900000, "208": 1494884606000, "209": 1495024998000, "210": 1495065920000, "211": 1495206276000, "212": 1495209842000, "213": 1495222309000, "214": 1495297803000, "215": 1495298449000, "216": 1495301478000, "217": 1495337488000, "218": 1495338273000, "219": 1495338550000, "220": 1495338667000, "221": 1495339246000, "222": 1495339584000, "223": 1495396978000, "224": 1496096516000, "225": 1496178386000, "226": 1496180803000, "227": 1496182359000, "228": 1496182703000, "229": 1496249492000, "230": 1496368756000, "231": 1496627633000, "232": 1496628822000, "233": 1496785286000, "234": 1496931143000, "235": 1496934891000, "236": 1496942023000, "237": 1496950240000, "238": 1496952167000, "239": 1496964728000, "240": 1496968159000, "241": 1497409142000, "242": 1497452288000, "243": 1497472603000, "244": 1497472704000, "245": 1497972319000, "246": 1498189738000, "247": 1499179416000, "248": 1501385354000, "249": 1501559041000, "250": 1501617741000, "251": 1502134281000, "252": 1504890984000, "253": 1504891091000, "254": 1505249199000, "255": 1505780506000, "256": 1505783843000, "257": 1505785223000, "258": 1506105156000, "259": 1506106487000, "260": 1510196351000, "261": 1510196376000, "262": 1510243772000, "263": 1510256205000, "264": 1510256457000, "265": 1510354783000, "266": 1510363149000, "267": 1510370189000, "268": 1510370879000, "269": 1510417160000, "270": 1511896940000, "271": 1513401811000, "272": 1513454464000, "273": 1513698223000, "274": 1513698910000, "275": 1514392082000, "276": 1514406492000, "277": 1514407104000, "278": 1514409438000, "279": 1514411270000, "280": 1514412721000, "281": 1514915389000, "282": 1514917016000, "283": 1514923171000, "284": 1514947571000, "285": 1516930913000, "286": 1518559244000, "287": 1518560104000, "288": 1518562925000, "289": 1518620558000, "290": 1518750877000, "291": 1518751788000, "292": 1518752025000, "293": 1518752479000, "294": 1518791194000, "295": 1518795059000, "296": 1518798160000, "297": 1519446859000, "298": 1519447788000, "299": 1519448239000, "300": 1519448835000, "301": 1519491931000, "302": 1519496775000, "303": 1519497553000, "304": 1519499407000, "305": 1519512356000, "306": 1519675436000, "307": 1519675882000, "308": 1519832299000, "309": 1519833452000, "310": 1520871034000, "311": 1522527169000, "312": 1522529852000, "313": 1522549453000, "314": 1522592418000, "315": 1522593068000, "316": 1522593455000, "317": 1524432091000, "318": 1524494327000, "319": 1524670616000, "320": 1524671424000, "321": 1524675718000, "322": 1524694031000, "323": 1524712697000, "324": 1524713128000, "325": 1524713762000, "326": 1525034826000, "327": 1525041735000, "328": 1525056549000, "329": 1525119421000, "330": 1525136861000, "331": 1525142163000, "332": 1525179074000, "333": 1525180467000, "334": 1525181695000, "335": 1525182473000, "336": 1525298887000, "337": 1525316072000, "338": 1525354167000, "339": 1525354340000, "340": 1525368453000, "341": 1525399848000, "342": 1525403033000, "343": 1525529932000, "344": 1525530545000, "347": 1526753540000, "349": 1526764894000, "350": 1526847607000, "351": 1526848612000, "352": 1526909812000, "353": 1526922316000, "354": 1526928399000, "355": 1526930806000, "356": 1526935524000, "357": 1526935966000, "358": 1526943416000, "359": 1526955921000, "360": 1526956925000, "361": 1526957453000, "362": 1526958112000, "363": 1526958380000, "364": 1526958982000, "365": 1526959337000, "366": 1526960105000, "367": 1526960495000, "368": 1526998097000, "369": 1527002114000, "370": 1527018315000, "371": 1527043492000, "372": 1527044274000, "373": 1527075769000, "374": 1527077898000, "375": 1527079214000, "376": 1527079821000, "377": 1527081064000, "378": 1527082162000, "379": 1527087053000, "380": 1527092945000, "381": 1527096833000, "382": 1527105852000, "383": 1527112531000, "384": 1527114315000, "385": 1527123480000, "386": 1527124648000, "387": 1527174739000, "388": 1528371701000, "389": 1528379727000, "390": 1528406684000, "391": 1528440735000, "392": 1528441463000, "393": 1528444498000, "394": 1528538925000, "395": 1528540711000, "396": 1528541380000, "397": 1528541711000, "398": 1528716959000, "399": 1528808383000, "400": 1528880667000, "401": 1529185822000, "402": 1529193955000, "403": 1529283329000, "404": 1529345117000, "405": 1529430331000, "406": 1529431460000, "407": 1529438913000, "408": 1530474102000, "409": 1530624594000, "410": 1530635820000, "411": 1530655267000, "412": 1530656971000, "413": 1530719495000, "414": 1530726252000, "415": 1530797804000, "416": 1530798463000, "417": 1530930873000, "418": 1530940069000, "419": 1530997299000, "420": 1530997380000, "421": 1530997536000, "422": 1530998689000, "423": 1531238552000, "424": 1531318844000, "425": 1531339814000, "426": 1531340429000, "427": 1531363479000, "428": 1531499578000, "429": 1531512638000, "430": 1531589262000, "431": 1531748219000, "432": 1531748631000, "433": 1531918486000, "434": 1531919524000, "435": 1532285855000, "436": 1532314373000, "437": 1532350531000, "438": 1532356654000, "439": 1532358662000, "440": 1537882938000, "441": 1537883740000, "442": 1537885952000, "443": 1537886691000, "444": 1537888456000, "445": 1537889161000, "446": 1537889905000, "447": 1537890540000, "448": 1537894545000, "449": 1537895600000, "450": 1539816660000, "451": 1539820656000, "452": 1539832607000, "453": 1539918964000, "465": 1540581219000, "466": 1540582198000, "467": 1540582440000, "468": 1540582625000, "469": 1540598297000, "470": 1540647817000, "471": 1540655059000, "476": 1540675934000, "477": 1540688763000, "478": 1540741902000, "479": 1540829830000, "480": 1541614426000, "481": 1541779141000, "482": 1542157711000, "483": 1542742944000, "484": 1542743510000, "485": 1544205390000, "486": 1544205931000, "487": 1545428579000, "488": 1547954008000, "489": 1552682158000, "490": 1553503615000, "491": 1553504750000, "492": 1553505319000, "493": 1553506131000, "494": 1553506931000, "498": 1556010056000, "500": 1556010837000, "501": 1556012539000, "502": 1556091530000, "503": 1556093925000, "506": 1556174462000, "513": 1556279004000, "514": 1556279261000, "515": 1556282480000, "516": 1556283788000, "517": 1556310016000, "518": 1556526594000, "519": 1559917054000, "524": 1562055497000, "525": 1562058422000, "528": 1562138653000, "529": 1562327862000, "530": 1562328326000, "531": 1564655711000, "533": 1567434996000, "539": 1567502584000, "540": 1567693528000, "541": 1567695342000, "545": 1567711369000, "546": 1568185240000, "549": 1570190082000, "550": 1570190984000, "561": 1571144838000, "562": 1571148393000, "563": 1571148817000, "570": 1571745331000, "571": 1571753492000, "572": 1571820840000, "573": 1572294579000, "574": 1572379226000, "586": 1572467655000, "589": 1572471852000, "592": 1572613642000, "593": 1572678252000, "594": 1573025116000, "595": 1573026548000, "599": 1573313545000, "600": 1573396642000, "606": 1573479049000, "607": 1573480641000, "609": 1573631359000, "613": 1573824211000, "614": 1574151878000, "622": 1574432794000, "623": 1574436047000, "624": 1574513784000, "626": 1574844895000, "627": 1575392089000, "630": 1575644175000, "631": 1578163241000, "632": 1578176092000, "638": 1578219603000, "640": 1578225203000, "650": 1581848631000, "651": 1581849452000, "653": 1582104387000, "654": 1582275325000, "668": 1583345741000, "670": 1583349515000, "719": 1584195166000, "733": 1584969847000, "740": 1588155173000, "742": 1588675599000, "749": 1591267070000, "754": 1592588497000, "760": 1593418667000, "762": 1593668590000, "763": 1593680137000, "766": 1593854747000, "767": 1594196767000, "771": 1597728988000, "774": 1597818082000, "779": 1600770974000, "801": 1606750359000, "802": 1606750577000, "807": 1607516338000, "808": 1607517762000, "810": 1607518474000, "811": 1607581545000, "813": 1610294709000, "820": 1610709679000, "822": 1611093154000, "824": 1614586212000, "832": 1614603287000, "838": 1615836641000, "849": 1616779396000, "857": 1619251326000, "859": 1621750472000, "863": 1622398453000, "864": 1622399579000, "868": 1622401674000, "871": 1624431509000, "877": 1625393788000}, "params": {"arch": ["x86_64"], "cpu": ["Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz"], "machine": ["dtr-laptop", "dtr-latitude"], "num_cpu": ["4", null], "os": ["Linux 4.18.0-20-generic", "Linux 5.4.0-48-generic"], "ram": ["16275844", "16307368"], "python": ["3.6", "3.8"], "numpy": ["1.17", null], "branch": ["main"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz", "machine": "dtr-laptop", "num_cpu": "4", "os": "Linux 5.4.0-48-generic", "ram": "16275844", "python": "3.8", "numpy": "1.17", "branch": "main"}, {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz", "machine": "dtr-laptop", "num_cpu": "4", "os": "Linux 5.4.0-48-generic", "ram": "16275844", "python": "3.8", "branch": "main", "numpy": null}, {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz", "machine": "dtr-latitude", "os": "Linux 4.18.0-20-generic", "ram": "16307368", "python": "3.6", "branch": "main", "num_cpu": null, "numpy": null}, {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz", "machine": "dtr-latitude", "os": "Linux 4.18.0-20-generic", "ram": "16307368", "python": "3.6", "numpy": "1.17", "branch": "main", "num_cpu": null}], "benchmarks": {"kernel.Kernel.time_fields": {"code": "class Kernel:\n    def time_fields(self, data, size):\n        kernel.fields(**data[size]['fields'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:\n            data[size] = {}\n    \n            if size == 'Small':\n                freq = np.array([1])\n                off = np.array([500.])\n                base = np.array([1])\n            else:\n                freq = np.logspace(-2, 2, 100)\n                off = np.arange(1, 101)*200.\n                base = filters.key_201_2009().base\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            xdirect = False\n            TM = True\n    \n            # Compute eta, zeta, wavenumber, Gamma\n            etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n            etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                  epermV*epsilon_0)\n            zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n            zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n            lambd = base/off[:, None]\n            Gam = np.sqrt((etaH/etaV)[:, None, :, None] *\n                          (lambd*lambd)[None, :, None, :] +\n                          (zetaH*etaH)[:, None, :, None])\n    \n            # Collect input for kernel.greenfct()\n            green_wave = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec':\n                          lrec, 'depth': depth, 'etaH': etaH, 'etaV': etaV,\n                          'zetaH': zetaH, 'zetaV': zetaV, 'lambd': lambd, 'ab':\n                          ab, 'xdirect': xdirect, 'msrc': msrc, 'mrec': mrec}\n    \n            # Collect input for kernel.reflections()\n            reflections = {'depth': depth, 'e_zH': etaH, 'Gam': Gam, 'lrec':\n                           lrec, 'lsrc': lsrc}\n    \n            if not VERSION2:\n                green_wave['use_ne_eval'] = use_ne_eval\n                reflections['use_ne_eval'] = use_ne_eval\n    \n            # Compute plus/minus reflection coefficients\n            Rp, Rm = kernel.reflections(**reflections)\n    \n            # Collect input for kernel.fields()\n            fields = {'depth': depth, 'Gam': Gam, 'lrec': lrec, 'lsrc': lsrc,\n                      'Rp': Rp, 'Rm': Rm, 'zsrc': zsrc, 'ab': ab, 'TM': TM}\n            if not VERSION2:\n                fields['use_ne_eval'] = use_ne_eval\n    \n            # Add to dict.\n            data[size]['green_wave'] = green_wave\n            data[size]['reflections'] = reflections\n            data[size]['fields'] = fields\n    \n        return data", "min_run_count": 2, "name": "kernel.Kernel.time_fields", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/kernel.py:39", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f98f1365b371a5580c0353eff53214eb636c20ed79e068d2c8b8dfed450b2e09", "warmup_time": -1}, "kernel.Kernel.time_greenfct": {"code": "class Kernel:\n    def time_greenfct(self, data, size):\n        kernel.greenfct(**data[size]['green_wave'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:\n            data[size] = {}\n    \n            if size == 'Small':\n                freq = np.array([1])\n                off = np.array([500.])\n                base = np.array([1])\n            else:\n                freq = np.logspace(-2, 2, 100)\n                off = np.arange(1, 101)*200.\n                base = filters.key_201_2009().base\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            xdirect = False\n            TM = True\n    \n            # Compute eta, zeta, wavenumber, Gamma\n            etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n            etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                  epermV*epsilon_0)\n            zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n            zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n            lambd = base/off[:, None]\n            Gam = np.sqrt((etaH/etaV)[:, None, :, None] *\n                          (lambd*lambd)[None, :, None, :] +\n                          (zetaH*etaH)[:, None, :, None])\n    \n            # Collect input for kernel.greenfct()\n            green_wave = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec':\n                          lrec, 'depth': depth, 'etaH': etaH, 'etaV': etaV,\n                          'zetaH': zetaH, 'zetaV': zetaV, 'lambd': lambd, 'ab':\n                          ab, 'xdirect': xdirect, 'msrc': msrc, 'mrec': mrec}\n    \n            # Collect input for kernel.reflections()\n            reflections = {'depth': depth, 'e_zH': etaH, 'Gam': Gam, 'lrec':\n                           lrec, 'lsrc': lsrc}\n    \n            if not VERSION2:\n                green_wave['use_ne_eval'] = use_ne_eval\n                reflections['use_ne_eval'] = use_ne_eval\n    \n            # Compute plus/minus reflection coefficients\n            Rp, Rm = kernel.reflections(**reflections)\n    \n            # Collect input for kernel.fields()\n            fields = {'depth': depth, 'Gam': Gam, 'lrec': lrec, 'lsrc': lsrc,\n                      'Rp': Rp, 'Rm': Rm, 'zsrc': zsrc, 'ab': ab, 'TM': TM}\n            if not VERSION2:\n                fields['use_ne_eval'] = use_ne_eval\n    \n            # Add to dict.\n            data[size]['green_wave'] = green_wave\n            data[size]['reflections'] = reflections\n            data[size]['fields'] = fields\n    \n        return data", "min_run_count": 2, "name": "kernel.Kernel.time_greenfct", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/kernel.py:39", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c3d5fedaea5f34aa73e47c03b1d1f767cce1f75c19c78607e11434d3dd4b0b55", "warmup_time": -1}, "kernel.Kernel.time_reflections": {"code": "class Kernel:\n    def time_reflections(self, data, size):\n        kernel.reflections(**data[size]['reflections'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:\n            data[size] = {}\n    \n            if size == 'Small':\n                freq = np.array([1])\n                off = np.array([500.])\n                base = np.array([1])\n            else:\n                freq = np.logspace(-2, 2, 100)\n                off = np.arange(1, 101)*200.\n                base = filters.key_201_2009().base\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            xdirect = False\n            TM = True\n    \n            # Compute eta, zeta, wavenumber, Gamma\n            etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n            etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                  epermV*epsilon_0)\n            zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n            zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n            lambd = base/off[:, None]\n            Gam = np.sqrt((etaH/etaV)[:, None, :, None] *\n                          (lambd*lambd)[None, :, None, :] +\n                          (zetaH*etaH)[:, None, :, None])\n    \n            # Collect input for kernel.greenfct()\n            green_wave = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec':\n                          lrec, 'depth': depth, 'etaH': etaH, 'etaV': etaV,\n                          'zetaH': zetaH, 'zetaV': zetaV, 'lambd': lambd, 'ab':\n                          ab, 'xdirect': xdirect, 'msrc': msrc, 'mrec': mrec}\n    \n            # Collect input for kernel.reflections()\n            reflections = {'depth': depth, 'e_zH': etaH, 'Gam': Gam, 'lrec':\n                           lrec, 'lsrc': lsrc}\n    \n            if not VERSION2:\n                green_wave['use_ne_eval'] = use_ne_eval\n                reflections['use_ne_eval'] = use_ne_eval\n    \n            # Compute plus/minus reflection coefficients\n            Rp, Rm = kernel.reflections(**reflections)\n    \n            # Collect input for kernel.fields()\n            fields = {'depth': depth, 'Gam': Gam, 'lrec': lrec, 'lsrc': lsrc,\n                      'Rp': Rp, 'Rm': Rm, 'zsrc': zsrc, 'ab': ab, 'TM': TM}\n            if not VERSION2:\n                fields['use_ne_eval'] = use_ne_eval\n    \n            # Add to dict.\n            data[size]['green_wave'] = green_wave\n            data[size]['reflections'] = reflections\n            data[size]['fields'] = fields\n    \n        return data", "min_run_count": 2, "name": "kernel.Kernel.time_reflections", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/kernel.py:39", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "72216c7465fa9a666a0116e54b3de5a0e25d98ab90f11e2f9477756d532754e5", "warmup_time": -1}, "kernel.Kernel.time_wavenumber": {"code": "class Kernel:\n    def time_wavenumber(self, data, size):\n        kernel.wavenumber(**data[size]['green_wave'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:\n            data[size] = {}\n    \n            if size == 'Small':\n                freq = np.array([1])\n                off = np.array([500.])\n                base = np.array([1])\n            else:\n                freq = np.logspace(-2, 2, 100)\n                off = np.arange(1, 101)*200.\n                base = filters.key_201_2009().base\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            xdirect = False\n            TM = True\n    \n            # Compute eta, zeta, wavenumber, Gamma\n            etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n            etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                  epermV*epsilon_0)\n            zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n            zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n            lambd = base/off[:, None]\n            Gam = np.sqrt((etaH/etaV)[:, None, :, None] *\n                          (lambd*lambd)[None, :, None, :] +\n                          (zetaH*etaH)[:, None, :, None])\n    \n            # Collect input for kernel.greenfct()\n            green_wave = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec':\n                          lrec, 'depth': depth, 'etaH': etaH, 'etaV': etaV,\n                          'zetaH': zetaH, 'zetaV': zetaV, 'lambd': lambd, 'ab':\n                          ab, 'xdirect': xdirect, 'msrc': msrc, 'mrec': mrec}\n    \n            # Collect input for kernel.reflections()\n            reflections = {'depth': depth, 'e_zH': etaH, 'Gam': Gam, 'lrec':\n                           lrec, 'lsrc': lsrc}\n    \n            if not VERSION2:\n                green_wave['use_ne_eval'] = use_ne_eval\n                reflections['use_ne_eval'] = use_ne_eval\n    \n            # Compute plus/minus reflection coefficients\n            Rp, Rm = kernel.reflections(**reflections)\n    \n            # Collect input for kernel.fields()\n            fields = {'depth': depth, 'Gam': Gam, 'lrec': lrec, 'lsrc': lsrc,\n                      'Rp': Rp, 'Rm': Rm, 'zsrc': zsrc, 'ab': ab, 'TM': TM}\n            if not VERSION2:\n                fields['use_ne_eval'] = use_ne_eval\n    \n            # Add to dict.\n            data[size]['green_wave'] = green_wave\n            data[size]['reflections'] = reflections\n            data[size]['fields'] = fields\n    \n        return data", "min_run_count": 2, "name": "kernel.Kernel.time_wavenumber", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/kernel.py:39", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f4e623f865f390d83a5b9319c503b8ef3f1c2ffa9bbd90dcaf30f106a49dd37a", "warmup_time": -1}, "model.Analytical.time_analytical": {"code": "class Analytical:\n    def time_analytical(self, solution):\n        model.analytical(**self.hsfs_inp)\n\n    def setup(self, solution):\n        if solution == 'dfs':\n            signal = 0\n        else:\n            signal = None\n    \n        self.hsfs_inp = {\n                'src': [0, 0, 0],\n                'rec': [np.arange(1, 101)*200, np.zeros(100), 0],\n                'res': 3.5,\n                'freqtime': np.logspace(-2, 2, 101),\n                'signal': signal,\n                'solution': solution,\n                'verb': 0}", "min_run_count": 2, "name": "model.Analytical.time_analytical", "number": 0, "param_names": ["solution"], "params": [["'fs'", "'dhs'", "'dfs'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b07b2319ed2d72709b609713b1ba9e4ab118e013c11069916485523a4d57c64a", "warmup_time": -1}, "model.Bipole.time_frequency": {"code": "class Bipole:\n    def time_frequency(self):\n        model.bipole(\n                src=[[-50, 0], [0, 30],\n                     [0, 10], [5, 50],\n                     [970, 999], [980, 990]],\n                rec=[[2000, 3000], [2100, 3200],\n                     [0, 200], [100, 400],\n                     [960, 970], [950, 1000]],\n                depth=[0, 1000, 2000, 2100],\n                res=[2e14, 0.3, 1, 100, 1],\n                freqtime=[0.1, 1.0, 10.],\n                srcpts=5, recpts=5, strength=1000,\n                htarg=HTARG201,\n                xdirect=False, verb=0)", "min_run_count": 2, "name": "model.Bipole.time_frequency", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "47353ab58e0a26dacf855695e87e9efe141123a8a7fa113807e4eddc10d89e58", "warmup_time": -1}, "model.Bipole.time_time": {"code": "class Bipole:\n    def time_time(self):\n        model.bipole(\n                src=[0, 0, 950, 10, 30],\n                rec=[3000, 100, 1000, 5, 7],\n                depth=[0, 1000, 2000, 2100],\n                res=[2e14, 0.3, 1, 100, 1],\n                freqtime=[0.1, 1.0, 10.],\n                htarg=HTARG201,\n                srcpts=1, recpts=1, strength=0,\n                signal=-1, xdirect=False, verb=0)", "min_run_count": 2, "name": "model.Bipole.time_time", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "642044d6efccb8895174e3379793ff1af98616a968d001ee73ad9cdc1485d701", "warmup_time": -1}, "model.Dipole.time_frequency": {"code": "class Dipole:\n    def time_frequency(self, loop):\n        self.freq(rec=[np.arange(1, 21)*300, np.zeros(20), 1000],\n                  **self.fmodel)\n\n    def setup(self, loop):\n        self.model = {\n                'src': [0, 0, 990],\n                'depth': [0, 1000, 2000, 2100],\n                'res': [2e14, 0.3, 1, 100, 1],\n                'xdirect': False,\n                'htarg': HTARG201,\n                'loop': loop,\n                'verb': 0}\n        if not VERSION2:\n            self.model['opt'] = None\n    \n        self.freqtime = np.logspace(-2, 2, 21)\n        self.fmodel = dc(self.model)\n        self.tmodel = dc(self.model)\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            # Test\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            # Frequency\n            self.freq = model.dipole\n            self.fmodel['freqtime'] = self.freqtime\n            # Time\n            self.time = model.dipole\n            self.tmodel['freqtime'] = self.freqtime\n        except VariableCatch:\n            # Frequency\n            self.freq = model.frequency\n            self.fmodel['freq'] = self.freqtime\n            # Time\n            self.time = model.time\n            self.tmodel['time'] = self.freqtime", "min_run_count": 2, "name": "model.Dipole.time_frequency", "number": 0, "param_names": ["loop"], "params": [["None", "'freq'", "'off'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "36d356d2200c8d96bb36c7dc5b147f723b880df1b230a44d537852af2243c37f", "warmup_time": -1}, "model.Dipole.time_time": {"code": "class Dipole:\n    def time_time(self, loop):\n        self.time(rec=[np.arange(1, 4)*1000, np.zeros(3), 1000],\n                  signal=0, **self.tmodel)\n\n    def setup(self, loop):\n        self.model = {\n                'src': [0, 0, 990],\n                'depth': [0, 1000, 2000, 2100],\n                'res': [2e14, 0.3, 1, 100, 1],\n                'xdirect': False,\n                'htarg': HTARG201,\n                'loop': loop,\n                'verb': 0}\n        if not VERSION2:\n            self.model['opt'] = None\n    \n        self.freqtime = np.logspace(-2, 2, 21)\n        self.fmodel = dc(self.model)\n        self.tmodel = dc(self.model)\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            # Test\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            # Frequency\n            self.freq = model.dipole\n            self.fmodel['freqtime'] = self.freqtime\n            # Time\n            self.time = model.dipole\n            self.tmodel['freqtime'] = self.freqtime\n        except VariableCatch:\n            # Frequency\n            self.freq = model.frequency\n            self.fmodel['freq'] = self.freqtime\n            # Time\n            self.time = model.time\n            self.tmodel['time'] = self.freqtime", "min_run_count": 2, "name": "model.Dipole.time_time", "number": 0, "param_names": ["loop"], "params": [["None", "'freq'", "'off'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9206bd4cdbe343d3e20d9c087690a8314fbfd2fba5c333fc9944a1c4edcf468f", "warmup_time": -1}, "model.VariousDipole.time_difflsrclrec_42": {"code": "class VariousDipole:\n    def time_difflsrclrec_42(self):\n        # First arguments without name, for backwards comp. with `frequency`\n        self.func([0, 0, -20],             # src\n                  [np.arange(1, 11)*600, np.zeros(10), 100],  # rec\n                  [0, 50],                 # Depth\n                  [2e14, 10, 1],           # Resistivities\n                  np.logspace(-2, 2, 11),  # Frequencies\n                  aniso=[1, 2, 0.5], ab=42, xdirect=False,\n                  htarg=HTARG101, verb=0)\n\n    def setup(self):\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            self.func = model.dipole\n        except VariableCatch:\n            self.func = model.frequency", "min_run_count": 2, "name": "model.VariousDipole.time_difflsrclrec_42", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "53629e58f128b46bc581c45b514dc61f8bab669f881e07433d509087960f4cf3", "warmup_time": -1}, "model.VariousDipole.time_highfreq_11": {"code": "class VariousDipole:\n    def time_highfreq_11(self):\n        # First arguments without name, for backwards comp. with `frequency`\n        self.func([0, 0, 2],              # src\n                  [np.arange(1, 11), np.arange(1, 11)/4, 3],  # rec\n                  [0, 10],                # Depth\n                  [2e14, 10, 100],        # Resistivities\n                  np.logspace(6, 8, 11),  # Frequencies\n                  aniso=[1, 2, 0.5], ab=11, epermH=[1, 80, 5],\n                  epermV=[1, 40, 10], mpermH=[1, 1, 4], mpermV=[1, 2, 0.5],\n                  xdirect=False, htarg=HTARG401, verb=0)\n\n    def setup(self):\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            self.func = model.dipole\n        except VariableCatch:\n            self.func = model.frequency", "min_run_count": 2, "name": "model.VariousDipole.time_highfreq_11", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c654d2cead27ecde2c94af5d2f3a84ce1a3bda4fd937abcff1d5c58890e589d6", "warmup_time": -1}, "model.VariousDipole.time_land_angle_16": {"code": "class VariousDipole:\n    def time_land_angle_16(self):\n        # First arguments without name, for backwards comp. with `frequency`\n        self.func([0, 0, 1e-5],            # src\n                  [np.arange(1, 11)*600, np.arange(1, 11)*400, 1e-5],  # rec\n                  0,                       # Depth\n                  [2e14, 10],              # Resistivities\n                  np.logspace(-2, 2, 11),  # Frequencies\n                  ab=16, epermH=[0, 1], epermV=[0, 1], xdirect=False,\n                  htarg=HTARG101, verb=0)\n\n    def setup(self):\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            self.func = model.dipole\n        except VariableCatch:\n            self.func = model.frequency", "min_run_count": 2, "name": "model.VariousDipole.time_land_angle_16", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "17c631845109865248747fd48f239f96a026fb0f85b1bfc3314c9340b2c1d837", "warmup_time": -1}, "model.VariousDipole.time_marine_angle_12": {"code": "class VariousDipole:\n    def time_marine_angle_12(self):\n        # First arguments without name, for backwards comp. with `frequency`\n        self.func([0, 0, 990],             # src\n                  [np.arange(1, 11)*600, np.arange(1, 11)*400, 1000],  # rec\n                  [0, 1000],               # Depths\n                  [2e14, 0.3, 1],          # Resistivities\n                  np.logspace(-2, 2, 11),  # Frequencies\n                  ab=12, xdirect=False, htarg=HTARG101, verb=0)\n\n    def setup(self):\n    \n        # Till c73d6647 (btw. v1.0.0 and v1.1.0) there were the routines\n        # `frequency` and `time`, which were later merged into `dipole`.\n        try:\n            model.dipole([0, 0, 1], [10, 0, 2], [], 1, 1, verb=0)\n            self.func = model.dipole\n        except VariableCatch:\n            self.func = model.frequency", "min_run_count": 2, "name": "model.VariousDipole.time_marine_angle_12", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3bf98047f07f76fc4e913cfa3bd53c4481fe8256370c4afe999dc20db7d8f06d", "warmup_time": -1}, "transform.Dlf.time_dlf": {"code": "class Dlf:\n    def time_dlf(self, data, size, htype):\n        transform.dlf(**data[size][htype])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n    \n            data[size] = {}\n    \n            # One big, one small model\n            if size == 'Small':  # Small; Total size: 5*1*1*1 = 5\n                x = np.array([500., 1000.])\n            else:       # Big; Total size: 5*100*100*201 = 10'050'000\n                x = np.arange(1, 101)*200.\n    \n            # Define model parameters\n            freq = np.array([1])\n            src = [0, 0, 250]\n            rec = [x, np.zeros(x.shape), 300]\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            ab = 11\n            xdirect = False\n            verb = 0\n    \n            if not VERSION2:\n                use_ne_eval = False\n    \n            # Checks (since DLF exists the `utils`-checks haven't changed, so\n            # we just use them here.\n            model = utils.check_model(depth, res, None, None, None, None, None,\n                                      xdirect, verb)\n            depth, res, aniso, epermH, epermV, mpermH, mpermV, _ = model\n            frequency = utils.check_frequency(freq, res, aniso, epermH, epermV,\n                                              mpermH, mpermV, verb)\n            freq, etaH, etaV, zetaH, zetaV = frequency\n            ab, msrc, mrec = utils.check_ab(ab, verb)\n            src, nsrc = utils.check_dipole(src, 'src', verb)\n            rec, nrec = utils.check_dipole(rec, 'rec', verb)\n            off, angle = utils.get_off_ang(src, rec, nsrc, nrec, verb)\n            lsrc, zsrc = utils.get_layer_nr(src, depth)\n            lrec, zrec = utils.get_layer_nr(rec, depth)\n    \n            for htype in self.params[1]:  # htype\n    \n                # pts_per_dec depending on htype\n                if htype == 'Standard':\n                    pts_per_dec = 0\n                elif htype == 'Lagged':\n                    pts_per_dec = -1\n                else:\n                    pts_per_dec = 10\n    \n                # Compute kernels for dlf\n                if VERSION2:\n                    # HT arguments\n                    _, fhtarg = utils.check_hankel(\n                            'dlf',\n                            {'dlf': 'key_201_2009',\n                             'pts_per_dec': pts_per_dec},\n                            0)\n    \n                    inp = (fhtarg['dlf'], off, fhtarg['pts_per_dec'])\n                    lambd, _ = transform.get_dlf_points(*inp)\n                else:\n                    # HT arguments\n                    _, fhtarg = utils.check_hankel(\n                            'fht', ['key_201_2009', pts_per_dec], 0)\n    \n                    inp = (fhtarg[0], off, fhtarg[1])\n                    lambd, _ = transform.get_spline_values(*inp)\n    \n                if VERSION2:\n                    inp = (zsrc, zrec, lsrc, lrec, depth, etaH, etaV, zetaH,\n                           zetaV, lambd, ab, xdirect, msrc, mrec)\n                else:\n                    inp = (zsrc, zrec, lsrc, lrec, depth, etaH,\n                           etaV, zetaH, zetaV, lambd, ab, xdirect,\n                           msrc, mrec, use_ne_eval)\n                PJ = kernel.wavenumber(*inp)\n    \n                factAng = kernel.angle_factor(angle, ab, msrc, mrec)\n    \n                # Signature changed at commit a15af07 (20/05/2018; before\n                # v1.6.2)\n                try:\n                    dlf = {'signal': PJ, 'points': lambd, 'out_pts': off,\n                           'ab': ab}\n                    if VERSION2:\n                        dlf['ang_fact'] = factAng\n                        dlf['filt'] = fhtarg['dlf']\n                        dlf['pts_per_dec'] = fhtarg['pts_per_dec']\n                    else:\n                        dlf['factAng'] = factAng\n                        dlf['filt'] = fhtarg[0]\n                        dlf['pts_per_dec'] = fhtarg[1]\n                    transform.dlf(**dlf)\n                except VariableCatch:\n                    dlf = {'signal': PJ, 'points': lambd, 'out_pts': off,\n                           'targ': fhtarg, 'factAng': factAng}\n    \n                data[size][htype] = dlf\n    \n        return data", "min_run_count": 2, "name": "transform.Dlf.time_dlf", "number": 0, "param_names": ["size", "htype"], "params": [["'Small'", "'Big'"], ["'Standard'", "'Lagged'", "'Splined'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/transform.py:281", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "55996ba517ec30a5f91f17b8683625424f4610d89147c9cedf375539df200e21", "warmup_time": -1}, "transform.Fourier.time_dlf_lagged": {"code": "class Fourier:\n    def time_dlf_lagged(self, data, size):\n        data[size]['fourier_dlf'](*data[size]['dlf_la'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel(\n                        'dlf', {'pts_per_dec': -1}, verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case and not VERSION2:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            elif VERSION2:\n                tdat['dlf_st'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 0})\n                tdat['dlf_la'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': -1})\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n    \n            if VERSION2:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 10})\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'qwe', {'pts_per_dec': 10})\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', {})\n    \n                # Get fourier_fft arguments\n                tdat['fft'] = get_args(freqtime, 'fft', {})\n    \n            else:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n                # Get fourier_fft arguments\n                if fft_and_ffht:\n                    tdat['fft'] = get_args(freqtime, 'fft', None)\n                else:\n                    tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data", "min_run_count": 2, "name": "transform.Fourier.time_dlf_lagged", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/transform.py:410", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "63e6f4137dc0e114a1ab46d1c656fe8dc2931173deba6cde94c35fb3526d327a", "warmup_time": -1}, "transform.Fourier.time_dlf_splined": {"code": "class Fourier:\n    def time_dlf_splined(self, data, size):\n        data[size]['fourier_dlf'](*data[size]['dlf_sp'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel(\n                        'dlf', {'pts_per_dec': -1}, verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case and not VERSION2:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            elif VERSION2:\n                tdat['dlf_st'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 0})\n                tdat['dlf_la'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': -1})\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n    \n            if VERSION2:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 10})\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'qwe', {'pts_per_dec': 10})\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', {})\n    \n                # Get fourier_fft arguments\n                tdat['fft'] = get_args(freqtime, 'fft', {})\n    \n            else:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n                # Get fourier_fft arguments\n                if fft_and_ffht:\n                    tdat['fft'] = get_args(freqtime, 'fft', None)\n                else:\n                    tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data", "min_run_count": 2, "name": "transform.Fourier.time_dlf_splined", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/transform.py:410", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "330ce0f957aab1c4eef62d1ebb0dd3791e0b65cf91e3ce5ef0bd4b140f819db5", "warmup_time": -1}, "transform.Fourier.time_dlf_standard": {"code": "class Fourier:\n    def time_dlf_standard(self, data, size):\n        data[size]['fourier_dlf'](*data[size]['dlf_st'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel(\n                        'dlf', {'pts_per_dec': -1}, verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case and not VERSION2:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            elif VERSION2:\n                tdat['dlf_st'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 0})\n                tdat['dlf_la'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': -1})\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n    \n            if VERSION2:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 10})\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'qwe', {'pts_per_dec': 10})\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', {})\n    \n                # Get fourier_fft arguments\n                tdat['fft'] = get_args(freqtime, 'fft', {})\n    \n            else:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n                # Get fourier_fft arguments\n                if fft_and_ffht:\n                    tdat['fft'] = get_args(freqtime, 'fft', None)\n                else:\n                    tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data", "min_run_count": 2, "name": "transform.Fourier.time_dlf_standard", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/transform.py:410", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8783c9c47cc78f3da3e4c471af349164c432135a60dfbe9764bb41a5b7fb26e2", "warmup_time": -1}, "transform.Fourier.time_fft": {"code": "class Fourier:\n    def time_fft(self, data, size):\n        data[size]['fourier_fft'](*data[size]['fft'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel(\n                        'dlf', {'pts_per_dec': -1}, verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case and not VERSION2:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            elif VERSION2:\n                tdat['dlf_st'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 0})\n                tdat['dlf_la'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': -1})\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n    \n            if VERSION2:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 10})\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'qwe', {'pts_per_dec': 10})\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', {})\n    \n                # Get fourier_fft arguments\n                tdat['fft'] = get_args(freqtime, 'fft', {})\n    \n            else:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n                # Get fourier_fft arguments\n                if fft_and_ffht:\n                    tdat['fft'] = get_args(freqtime, 'fft', None)\n                else:\n                    tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data", "min_run_count": 2, "name": "transform.Fourier.time_fft", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/transform.py:410", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e0e95450a71868b55476eae780f0f3a5fd8b277def4d7d7f3657b5e169b7a21a", "warmup_time": -1}, "transform.Fourier.time_fftlog": {"code": "class Fourier:\n    def time_fftlog(self, data, size):\n        data[size]['fourier_fftlog'](*data[size]['fftlog'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel(\n                        'dlf', {'pts_per_dec': -1}, verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case and not VERSION2:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            elif VERSION2:\n                tdat['dlf_st'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 0})\n                tdat['dlf_la'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': -1})\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n    \n            if VERSION2:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 10})\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'qwe', {'pts_per_dec': 10})\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', {})\n    \n                # Get fourier_fft arguments\n                tdat['fft'] = get_args(freqtime, 'fft', {})\n    \n            else:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n                # Get fourier_fft arguments\n                if fft_and_ffht:\n                    tdat['fft'] = get_args(freqtime, 'fft', None)\n                else:\n                    tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data", "min_run_count": 2, "name": "transform.Fourier.time_fftlog", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/transform.py:410", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e9c6676d841113bc59b4bff055ff5e460d9a3cdefd30192d9d80191cd013d15d", "warmup_time": -1}, "transform.Fourier.time_qwe": {"code": "class Fourier:\n    def time_qwe(self, data, size):\n        data[size]['fourier_qwe'](*data[size]['qwe'])\n\n    def setup_cache(self):\n        \"\"\"setup_cache is not parametrized, so we do it manually. \"\"\"\n    \n        data = {}\n        for size in self.params[0]:  # size\n            tdat = {}\n    \n            # One big, one small model\n            if size == 'Small':\n                freqtime = np.array([2.])\n            else:\n                freqtime = np.logspace(-1, 1, 11)\n    \n            # Define survey\n            lsrc = 1\n            lrec = 1\n            angle = np.array([0])\n            off = np.array([5000])\n            ab = 11\n            msrc = False\n            mrec = False\n    \n            if VERSION2:\n                zsrc = 250.\n                zrec = 300.\n            else:\n                zsrc = np.array([250.])  # Not sure if this distinction\n                zrec = np.array([300.])  # is actually needed\n                use_ne_eval = False\n    \n            # Define model\n            depth = np.array([-np.infty, 0, 300, 2000, 2100])\n            res = np.array([2e14, .3, 1, 50, 1])\n            aniso = np.ones(res.shape)\n            epermH = np.ones(res.shape)\n            epermV = np.ones(res.shape)\n            mpermH = np.ones(res.shape)\n            mpermV = np.ones(res.shape)\n    \n            # Other parameters\n            verb = 0\n            loop_freq = True\n            loop_off = False\n            signal = 0\n    \n            # Get Hankel arguments\n            if VERSION2:\n                ht, htarg = utils.check_hankel(\n                        'dlf', {'pts_per_dec': -1}, verb)\n            else:\n                # `pts_per_dec` changed at 9bed72b0 (29/04/2018; bef. v1.4.1)\n                try:\n                    ht, htarg = utils.check_hankel('fht', ['', -1], verb)\n                except VariableCatch:\n                    # `check_hankel`-signature changed at c73d6647\n                    try:\n                        ht, htarg = utils.check_hankel('fht', None, verb)\n                    except VariableCatch:\n                        ht, htarg = utils.check_hankel('fht', None, ab, verb)\n    \n            # Get frequency-domain stuff for time-domain computation\n            def get_args(freqtime, ft, ftarg):\n                time, freq, ft, ftarg = utils.check_time(\n                        freqtime, signal, ft, ftarg, verb)\n    \n                # Compute eta, zeta\n                etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n                etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq,\n                                                      epermV*epsilon_0)\n                zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n                zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n                # `model.fem`-signature changed on 9bed72b0\n                # (29/04/2018; bef. v1.4.1)\n                inp = (ab, off, angle, zsrc, zrec, lsrc, lrec, depth, freq,\n                       etaH, etaV, zetaH, zetaV, False, False, ht, htarg,\n                       msrc, mrec, loop_freq, loop_off)\n                try:\n                    if not VERSION2:\n                        inp = (*inp[:17], use_ne_eval, *inp[17:])\n                    out = model.fem(*inp)\n                except VariableCatch:\n                    out = model.fem(*inp[:17], True, *inp[17:])\n    \n                # `model.fem` returned in the beginning only fEM;\n                # then (fEM, kcount) and finally (fEM, kcount, conv).\n                if isinstance(out, tuple):\n                    fEM = np.squeeze(out[0])\n                else:\n                    fEM = np.squeeze(out)\n    \n                return (fEM, time, freq, ftarg)\n    \n            # Define function name of transform\n            fft_and_ffht = True\n            if VERSION2:\n                name_dlf = 'fourier_dlf'\n                name_fqwe = 'fourier_qwe'\n                name_fftlog = 'fourier_fftlog'\n                name_fft = 'fourier_fft'\n            else:\n                name_fqwe = 'fqwe'\n                name_fftlog = 'fftlog'\n                name_fft = 'fft'\n                # ffht used to be fft until the introduction of fft\n                try:\n                    getattr(transform, 'ffht')\n                    name_ffht = 'ffht'\n                except VariableCatch:\n                    fft_and_ffht = False\n                    name_ffht = 'fft'\n                name_dlf = name_ffht\n    \n            # Store functions\n            tdat['fourier_dlf'] = getattr(transform, name_dlf)\n            tdat['fourier_qwe'] = getattr(transform, name_fqwe)\n            tdat['fourier_fftlog'] = getattr(transform, name_fftlog)\n            tdat['fourier_fft'] = getattr(transform, name_fft)\n    \n            # Check default pts_per_dec to see if new or old case\n            if VERSION2:\n                old_case = False\n            else:\n                try:\n                    test = utils.check_time(freqtime, signal, 'sin',\n                                            ['key_201_CosSin_2012', 'test'], 0)\n                    old_case = test[3][1] is None\n                except VariableCatch:\n                    old_case = True\n    \n            # Get fourier_dlf arguments\n            if old_case and not VERSION2:\n                tdat['dlf_st'] = ()  # Standard was not possible in old case\n                tdat['dlf_la'] = get_args(freqtime, name_ffht, None)\n            elif VERSION2:\n                tdat['dlf_st'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 0})\n                tdat['dlf_la'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': -1})\n            else:\n                tdat['dlf_st'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 0])\n                tdat['dlf_la'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', -1])\n    \n            if VERSION2:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, 'dlf',\n                        {'dlf': 'key_201_CosSin_2012', 'pts_per_dec': 10})\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'qwe', {'pts_per_dec': 10})\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', {})\n    \n                # Get fourier_fft arguments\n                tdat['fft'] = get_args(freqtime, 'fft', {})\n    \n            else:\n                tdat['dlf_sp'] = get_args(\n                        freqtime, name_ffht, ['key_201_CosSin_2012', 10])\n    \n                # Get fourier_qwe arguments\n                tdat['qwe'] = get_args(freqtime, 'fqwe', ['', '', '', '', 10])\n    \n                # Get fourier_fftlog arguments\n                tdat['fftlog'] = get_args(freqtime, 'fftlog', None)\n    \n                # Get fourier_fft arguments\n                if fft_and_ffht:\n                    tdat['fft'] = get_args(freqtime, 'fft', None)\n                else:\n                    tdat['fft'] = ()  # Will fail\n    \n            data[size] = tdat\n    \n        return data", "min_run_count": 2, "name": "transform.Fourier.time_qwe", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/dtr/Codes/emsig/benchmarks/empymod-asv/benchmarks/transform.py:410", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5aad8eeffe5180007fdbf8df063fc510b450d9c5a3780a99edfa6c36e8883f6d", "warmup_time": -1}, "transform.Hankel.time_fht_lagged": {"code": "class Hankel:\n    def time_fht_lagged(self, size):\n        if VERSION2:\n            transform.hankel_dlf(**self.fhtarg_la, **self.hankel)\n        else:\n            transform.fht(**self.fhtarg_la, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `htarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            if VERSION2:\n                htarg = {'dlf': 'key_201_2009', 'pts_per_dec': -1}\n            else:\n                htarg = ['key_201_2009', -1]\n        else:\n            htarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n            htarg1 = {'dlf': 'key_201_2009', 'pts_per_dec': 0}\n            htarg2 = {'dlf': 'key_201_2009', 'pts_per_dec': 10}\n            name = 'dlf'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n            htarg1 = ['key_201_2009', 0]\n            htarg2 = ['key_201_2009', 10]\n            name = 'fht'\n    \n        _, fhtarg_st = utils.check_hankel(name, htarg1, *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel(name, htarg2, *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel(name, htarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            if VERSION2:\n                args_sp = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 10,\n                           'diff_quad': np.inf}\n                args_st = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 0,\n                           'diff_quad': np.inf}\n            else:\n                args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n                args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        if VERSION2:\n            args = {'atol': 1e-6, 'rtol': 1e-10, 'limit': 100, 'a': 1e-6,\n                    'b': 0.1, 'pts_per_dec': 10}\n        else:\n            args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})", "min_run_count": 2, "name": "transform.Hankel.time_fht_lagged", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6b43ab6cde985e47eb47f51d13e629848655d72e171f3269561fb7e9dff4a001", "warmup_time": -1}, "transform.Hankel.time_fht_splined": {"code": "class Hankel:\n    def time_fht_splined(self, size):\n        if VERSION2:\n            transform.hankel_dlf(**self.fhtarg_sp, **self.hankel)\n        else:\n            transform.fht(**self.fhtarg_sp, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `htarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            if VERSION2:\n                htarg = {'dlf': 'key_201_2009', 'pts_per_dec': -1}\n            else:\n                htarg = ['key_201_2009', -1]\n        else:\n            htarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n            htarg1 = {'dlf': 'key_201_2009', 'pts_per_dec': 0}\n            htarg2 = {'dlf': 'key_201_2009', 'pts_per_dec': 10}\n            name = 'dlf'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n            htarg1 = ['key_201_2009', 0]\n            htarg2 = ['key_201_2009', 10]\n            name = 'fht'\n    \n        _, fhtarg_st = utils.check_hankel(name, htarg1, *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel(name, htarg2, *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel(name, htarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            if VERSION2:\n                args_sp = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 10,\n                           'diff_quad': np.inf}\n                args_st = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 0,\n                           'diff_quad': np.inf}\n            else:\n                args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n                args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        if VERSION2:\n            args = {'atol': 1e-6, 'rtol': 1e-10, 'limit': 100, 'a': 1e-6,\n                    'b': 0.1, 'pts_per_dec': 10}\n        else:\n            args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})", "min_run_count": 2, "name": "transform.Hankel.time_fht_splined", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "cd178521d8830ab75a1e48bbd6a2bf14d49afe4c752678e658bde136a0a456d4", "warmup_time": -1}, "transform.Hankel.time_fht_standard": {"code": "class Hankel:\n    def time_fht_standard(self, size):\n        if VERSION2:\n            transform.hankel_dlf(**self.fhtarg_st, **self.hankel)\n        else:\n            transform.fht(**self.fhtarg_st, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `htarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            if VERSION2:\n                htarg = {'dlf': 'key_201_2009', 'pts_per_dec': -1}\n            else:\n                htarg = ['key_201_2009', -1]\n        else:\n            htarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n            htarg1 = {'dlf': 'key_201_2009', 'pts_per_dec': 0}\n            htarg2 = {'dlf': 'key_201_2009', 'pts_per_dec': 10}\n            name = 'dlf'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n            htarg1 = ['key_201_2009', 0]\n            htarg2 = ['key_201_2009', 10]\n            name = 'fht'\n    \n        _, fhtarg_st = utils.check_hankel(name, htarg1, *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel(name, htarg2, *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel(name, htarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            if VERSION2:\n                args_sp = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 10,\n                           'diff_quad': np.inf}\n                args_st = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 0,\n                           'diff_quad': np.inf}\n            else:\n                args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n                args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        if VERSION2:\n            args = {'atol': 1e-6, 'rtol': 1e-10, 'limit': 100, 'a': 1e-6,\n                    'b': 0.1, 'pts_per_dec': 10}\n        else:\n            args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})", "min_run_count": 2, "name": "transform.Hankel.time_fht_standard", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ef112ef202b3e2c7ae8ecd32c3b64820ce05750bb34429e08244aaf9a87a2afb", "warmup_time": -1}, "transform.Hankel.time_hquad": {"code": "class Hankel:\n    def time_hquad(self, size):\n        if VERSION2:\n            transform.hankel_quad(**self.quadargs, **self.hankel)\n        else:\n            transform.hquad(**self.quadargs, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `htarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            if VERSION2:\n                htarg = {'dlf': 'key_201_2009', 'pts_per_dec': -1}\n            else:\n                htarg = ['key_201_2009', -1]\n        else:\n            htarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n            htarg1 = {'dlf': 'key_201_2009', 'pts_per_dec': 0}\n            htarg2 = {'dlf': 'key_201_2009', 'pts_per_dec': 10}\n            name = 'dlf'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n            htarg1 = ['key_201_2009', 0]\n            htarg2 = ['key_201_2009', 10]\n            name = 'fht'\n    \n        _, fhtarg_st = utils.check_hankel(name, htarg1, *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel(name, htarg2, *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel(name, htarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            if VERSION2:\n                args_sp = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 10,\n                           'diff_quad': np.inf}\n                args_st = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 0,\n                           'diff_quad': np.inf}\n            else:\n                args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n                args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        if VERSION2:\n            args = {'atol': 1e-6, 'rtol': 1e-10, 'limit': 100, 'a': 1e-6,\n                    'b': 0.1, 'pts_per_dec': 10}\n        else:\n            args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})", "min_run_count": 2, "name": "transform.Hankel.time_hquad", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "23c0762c32d3b91e5f4b947fe1a1e9baad81e4a53f90af43778b13ef817a18c3", "warmup_time": -1}, "transform.Hankel.time_hqwe_splined": {"code": "class Hankel:\n    def time_hqwe_splined(self, size):\n        if VERSION2:\n            transform.hankel_qwe(**self.qwearg_sp, **self.hankel)\n        else:\n            transform.hqwe(**self.qwearg_sp, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `htarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            if VERSION2:\n                htarg = {'dlf': 'key_201_2009', 'pts_per_dec': -1}\n            else:\n                htarg = ['key_201_2009', -1]\n        else:\n            htarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n            htarg1 = {'dlf': 'key_201_2009', 'pts_per_dec': 0}\n            htarg2 = {'dlf': 'key_201_2009', 'pts_per_dec': 10}\n            name = 'dlf'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n            htarg1 = ['key_201_2009', 0]\n            htarg2 = ['key_201_2009', 10]\n            name = 'fht'\n    \n        _, fhtarg_st = utils.check_hankel(name, htarg1, *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel(name, htarg2, *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel(name, htarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            if VERSION2:\n                args_sp = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 10,\n                           'diff_quad': np.inf}\n                args_st = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 0,\n                           'diff_quad': np.inf}\n            else:\n                args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n                args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        if VERSION2:\n            args = {'atol': 1e-6, 'rtol': 1e-10, 'limit': 100, 'a': 1e-6,\n                    'b': 0.1, 'pts_per_dec': 10}\n        else:\n            args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})", "min_run_count": 2, "name": "transform.Hankel.time_hqwe_splined", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "16ca06e6b165be4a92effed3323cb6018dcd01b6bfe482f4a227100eb0c5c0c0", "warmup_time": -1}, "transform.Hankel.time_hqwe_standard": {"code": "class Hankel:\n    def time_hqwe_standard(self, size):\n        if VERSION2:\n            transform.hankel_qwe(**self.qwearg_st, **self.hankel)\n        else:\n            transform.hqwe(**self.qwearg_st, **self.hankel)\n\n    def setup(self, size):\n    \n        # One big, one small model\n        if size == 'Small':  # Total size: 5*1*1*1 = 5\n            off = np.array([500., 1000.])\n        else:          # Total size: 5*100*1*201 = 100'500\n            off = np.arange(1, 101)*200.\n    \n        # Define survey\n        freq = np.array([1])\n        lsrc = 1\n        lrec = 1\n        angle = np.zeros(off.shape)\n        ab = 11\n        msrc = False\n        mrec = False\n    \n        if VERSION2:\n            zsrc = 250.\n            zrec = 300.\n        else:\n            zsrc = np.array([250.])  # Not sure if this distinction\n            zrec = np.array([300.])  # is actually needed\n            use_ne_eval = False\n    \n        # Define model\n        depth = np.array([-np.infty, 0, 300, 2000, 2100])\n        res = np.array([2e14, .3, 1, 50, 1])\n        aniso = np.ones(res.shape)\n        epermH = np.ones(res.shape)\n        epermV = np.ones(res.shape)\n        mpermH = np.ones(res.shape)\n        mpermV = np.ones(res.shape)\n    \n        # Other parameters\n        xdirect = False\n        verb = 0\n    \n        # Compute eta, zeta\n        etaH = 1/res + np.outer(2j*np.pi*freq, epermH*epsilon_0)\n        etaV = 1/(res*aniso*aniso) + np.outer(2j*np.pi*freq, epermV*epsilon_0)\n        zetaH = np.outer(2j*np.pi*freq, mpermH*mu_0)\n        zetaV = np.outer(2j*np.pi*freq, mpermV*mu_0)\n    \n        # Collect input\n        self.hankel = {'zsrc': zsrc, 'zrec': zrec, 'lsrc': lsrc, 'lrec': lrec,\n                       'off': off, 'depth': depth, 'ab': ab, 'etaH': etaH,\n                       'etaV': etaV, 'zetaH': zetaH, 'zetaV': zetaV, 'xdirect':\n                       xdirect, 'msrc': msrc, 'mrec': mrec}\n        if not VERSION2:\n            self.hankel['use_ne_eval'] = use_ne_eval\n    \n        # Before c73d6647; you had to give `ab` to `check_hankel`;\n        # check_opt didn't exist then.\n        if VERSION2:\n            charg = (verb, )\n            new_version = True\n        else:\n            try:\n                opt = utils.check_opt(None, None, 'fht', ['', 0], verb)\n                charg = (verb, )\n                if np.size(opt) == 4:\n                    new_version = False\n                else:\n                    new_version = True\n            except VariableCatch:\n                new_version = False\n                charg = (ab, verb)\n    \n        # From 9bed72b0 onwards, there is no `use_spline`; `htarg` input\n        # changed (29/04/2018; before v1.4.1).\n        if new_version:\n            if VERSION2:\n                htarg = {'dlf': 'key_201_2009', 'pts_per_dec': -1}\n            else:\n                htarg = ['key_201_2009', -1]\n        else:\n            htarg = ['key_201_2009', None]\n    \n        # HT arguments\n        if VERSION2:\n            dlfargname = 'htarg'\n            qweargname = 'htarg'\n            quadargname = 'htarg'\n            htarg1 = {'dlf': 'key_201_2009', 'pts_per_dec': 0}\n            htarg2 = {'dlf': 'key_201_2009', 'pts_per_dec': 10}\n            name = 'dlf'\n        else:\n            dlfargname = 'fhtarg'\n            qweargname = 'qweargs'\n            quadargname = 'quadargs'\n            htarg1 = ['key_201_2009', 0]\n            htarg2 = ['key_201_2009', 10]\n            name = 'fht'\n    \n        _, fhtarg_st = utils.check_hankel(name, htarg1, *charg)\n        self.fhtarg_st = {dlfargname: fhtarg_st}\n        _, fhtarg_sp = utils.check_hankel(name, htarg2, *charg)\n        self.fhtarg_sp = {dlfargname: fhtarg_sp}\n        _, fhtarg_la = utils.check_hankel(name, htarg, *charg)\n        self.fhtarg_la = {dlfargname: fhtarg_la}\n    \n        # QWE: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'nquad', 'maxint', 'pts_per_dec', 'diff_quad', 'a',\n        # 'b', 'limit']\n    \n        # Args depend if QUAD included into QWE or not\n        try:\n            if VERSION2:\n                args_sp = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 10,\n                           'diff_quad': np.inf}\n                args_st = {'atol': 1e-6, 'rtol': 1e-10, 'nquad': 51,\n                           'maxint': 100, 'pts_per_dec': 0,\n                           'diff_quad': np.inf}\n            else:\n                args_sp = [1e-6, 1e-10, 51, 100, 10, np.inf]\n                args_st = [1e-6, 1e-10, 51, 100, 0, np.inf]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n        except VariableCatch:\n            args_sp = [1e-6, 1e-10, 51, 100, 10]\n            args_st = [1e-6, 1e-10, 51, 100, 0]\n            _, qwearg_sp = utils.check_hankel('qwe', args_sp, *charg)\n            _, qwearg_st = utils.check_hankel('qwe', args_st, *charg)\n    \n        self.qwearg_st = {qweargname: qwearg_st}\n        self.qwearg_sp = {qweargname: qwearg_sp}\n    \n        # QUAD: We lower the requirements here, otherwise it takes too long\n        # ['rtol', 'atol', 'limit', 'a', 'b', 'pts_per_dec']\n        if VERSION2:\n            args = {'atol': 1e-6, 'rtol': 1e-10, 'limit': 100, 'a': 1e-6,\n                    'b': 0.1, 'pts_per_dec': 10}\n        else:\n            args = [1e-6, 1e-10, 100, 1e-6, 0.1, 10]\n        try:  # QUAD only included since 6104614e (before v1.3.0)\n            _, quadargs = utils.check_hankel('quad', args, *charg)\n            self.quadargs = {quadargname: quadargs}\n        except VariableCatch:\n            self.quadargs = {}\n    \n        if not new_version and not VERSION2:\n            self.fhtarg_la.update({'use_spline': True})\n            self.fhtarg_sp.update({'use_spline': True})\n            self.fhtarg_st.update({'use_spline': False})\n            self.qwearg_sp.update({'use_spline': True})\n            self.qwearg_st.update({'use_spline': False})\n            self.quadargs.update({'use_spline': True})\n    \n        if VERSION2:\n            self.hankel['ang_fact'] = kernel.angle_factor(\n                    angle, ab, msrc, mrec)\n        else:\n            # From bb6447a onwards ht-transforms take `factAng`, not `angle`,\n            # to avoid re-calculation in loops.\n            try:\n                transform.fht(angle=angle, **self.fhtarg_la, **self.hankel)\n                self.hankel['angle'] = angle\n            except VariableCatch:\n                self.hankel['factAng'] = kernel.angle_factor(\n                        angle, ab, msrc, mrec)\n    \n        if not VERSION2:\n            # From b6f6872 onwards fht-transforms calculates lambd/int_pts in\n            # model.fem, not in transform.fht, to avoid re-calculation in\n            # loops.\n            try:\n                transform.fht(**self.fhtarg_la, **self.hankel)\n            except VariableCatch:\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_st[0], off, fhtarg_st[1])\n                self.fhtarg_st.update({'fhtarg': (\n                    fhtarg_st[0], fhtarg_st[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_la[0], off, fhtarg_la[1])\n                self.fhtarg_la.update(\n                        {'fhtarg':\n                         (fhtarg_la[0], fhtarg_la[1], lambd, int_pts)})\n                lambd, int_pts = transform.get_spline_values(\n                        fhtarg_sp[0], off, fhtarg_sp[1])\n                self.fhtarg_sp.update(\n                        {'fhtarg':\n                         (fhtarg_sp[0], fhtarg_sp[1], lambd, int_pts)})", "min_run_count": 2, "name": "transform.Hankel.time_hqwe_standard", "number": 0, "param_names": ["size"], "params": [["'Small'", "'Big'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1db0c9654ddfe3c25bf5aa3c565f08a49f9b80907de6e7c72108e874be06d010", "warmup_time": -1}}, "machines": {"dtr-laptop": {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz", "machine": "dtr-laptop", "num_cpu": "4", "os": "Linux 5.4.0-48-generic", "ram": "16275844", "version": 1}, "dtr-latitude": {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz", "machine": "dtr-latitude", "os": "Linux 4.18.0-20-generic", "ram": "16307368", "version": 1}}, "tags": {"v1.0.0": 27, "v1.1.0": 71, "v1.10.0": 562, "v1.10.1": 570, "v1.10.2": 595, "v1.10.3": 607, "v1.10.4": 651, "v1.10.5": 654, "v1.10.6": 670, "v1.2.0": 145, "v1.2.1": 170, "v1.3.0": 202, "v1.4.1": 227, "v1.4.2": 231, "v1.4.4": 256, "v1.5.0": 281, "v1.5.1": 303, "v1.5.2": 324, "v1.6.0": 334, "v1.6.1": 343, "v1.6.2": 356, "v1.7.0": 385, "v1.7.1": 405, "v1.7.2": 421, "v1.7.3": 431, "v1.8.0": 467, "v1.8.1": 483, "v1.8.2": 515, "v1.8.3": 529, "v1.9.0": 549, "v2.0.0": 740, "v2.0.0-rc.1": 719, "v2.0.0-rc.2": 733, "v2.0.1": 754, "v2.0.2": 763, "v2.0.3": 779, "v2.0.4": 810, "v2.0.5": 832, "v2.0.6": 849, "v2.1.0": 868, "v2.1.1": 871, "v2.1.2": 877}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}